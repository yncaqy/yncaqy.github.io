<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>DRF | YNCAQY</title><meta name="author" content="yncaqy"><meta name="copyright" content="yncaqy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="DRF框架1 DRF入门1.1 RESTful REST与技术无关，它是一种 软件架构风格 ，REST是Representational State Transfer的简称，中文翻译为“ 表征状态转移 ” REST从资源的角度类审视整个网络，它将分布在网络中某个节点的 资源通过URL进行标识 ，客户端应用通过URL来获取资源的表征，获得这些表征致使这些应用转变状态 所有的数据，不管是通过网络获取的">
<meta property="og:type" content="article">
<meta property="og:title" content="DRF">
<meta property="og:url" content="http://example.com/2023/04/14/DRF/index.html">
<meta property="og:site_name" content="YNCAQY">
<meta property="og:description" content="DRF框架1 DRF入门1.1 RESTful REST与技术无关，它是一种 软件架构风格 ，REST是Representational State Transfer的简称，中文翻译为“ 表征状态转移 ” REST从资源的角度类审视整个网络，它将分布在网络中某个节点的 资源通过URL进行标识 ，客户端应用通过URL来获取资源的表征，获得这些表征致使这些应用转变状态 所有的数据，不管是通过网络获取的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/2.jpg">
<meta property="article:published_time" content="2023-04-14T09:03:48.000Z">
<meta property="article:modified_time" content="2023-04-14T12:39:59.862Z">
<meta property="article:author" content="yncaqy">
<meta property="article:tag" content="test">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/2.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/14/DRF/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"简","msgToSimplifiedChinese":"繁"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: yncaqy","link":"链接: ","source":"来源: YNCAQY","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'DRF',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-14 20:39:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = 'hidden';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}

preloader.initLoading()
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img%5C2.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="YNCAQY"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo.png"/><span class="site-name">YNCAQY</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">DRF<a class="post-edit-link" href="null_posts/DRF.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-14T09:03:48.000Z" title="发表于 2023-04-14 17:03:48">2023-04-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-14T12:39:59.862Z" title="更新于 2023-04-14 20:39:59">2023-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/test/">test</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>57分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="DRF"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="DRF框架"><a href="#DRF框架" class="headerlink" title="DRF框架"></a>DRF框架</h4><h2 id="1-DRF入门"><a href="#1-DRF入门" class="headerlink" title="1 DRF入门"></a>1 DRF入门</h2><h3 id="1-1-RESTful"><a href="#1-1-RESTful" class="headerlink" title="1.1 RESTful"></a>1.1 RESTful</h3><ul>
<li>REST与技术无关，它是一种 <strong>软件架构风格</strong> ，REST是Representational State Transfer的简称，中文翻译为“ <strong>表征状态转移</strong> ”</li>
<li>REST从<strong>资源的角度</strong>类审视整个网络，它将分布在网络中某个节点的 <strong>资源通过URL进行标识</strong> ，客户端应用<strong>通过URL来获取资源</strong>的表征，获得这些表征致使这些应用转变状态</li>
<li>所有的数据，不管是通过网络获取的还是操作(增删改查)的数据，都是资源，<strong>将一切数据视为资源</strong>是REST区别与其他架构风格的最本质属性</li>
<li>对于REST这种面向资源的架构风格，有人提出一种全新的结构理念，即： <strong>面向资源架构</strong> （ROA：Resource Oriented Architecture）</li>
</ul>
<h3 id="1-2-API接口和-RESTful-API规范"><a href="#1-2-API接口和-RESTful-API规范" class="headerlink" title="1.2 API接口和 RESTful API规范"></a>1.2 API接口和 RESTful API规范</h3><p>1.2.1 API接口</p>
<ul>
<li>规定了前端和后端交互规则的URL连接，也就是前后端交互的媒介</li>
</ul>
<p>1.2.2 为什么要有规范</p>
<ul>
<li>为了在团队中达成共识、防止个人习惯差异引起的混乱</li>
<li>需要一个大家都认可的规范，减少合作成本</li>
</ul>
<p>1.2.3 API接口文档</p>
<ul>
<li>编写接口的用户、使用方法、数据格式等等</li>
<li>可以使用书写、或者使用工具自动生成（coreapi,swagger)</li>
</ul>
<p>1.2.4 RESTful API规范</p>
<ul>
<li>必须通过http来传输数据</li>
<li>必须api标志：<a target="_blank" rel="noopener" href="http://localhost:8080/api/xxx">http://localhost:8080/api/xxx</a></li>
<li>接口中要提现接口版本：<a target="_blank" rel="noopener" href="http://localhost:8080/api/v1/books">http://localhost:8080/api/v1/books</a></li>
<li>通过请求方法的不通来区分操作：<ul>
<li>查询：GET</li>
<li>POST：新增和提交数据</li>
<li>PUT：修改数据</li>
<li>PATCH：局部修改数据</li>
<li>DELETE：删除数据</li>
</ul>
</li>
<li>请求路径中带过滤，在URL后面带参数：<a target="_blank" rel="noopener" href="https://api.example.com/v1/?name=%27%E9%87%91%27&order=asc">https://api.example.com/v1/?name=&#39;金&#39;&amp;order=asc</a></li>
<li>返回响应数据中携带响应状态码</li>
<li>返回数据中携带错误信息：{error : ‘错误信息’}</li>
<li>针对不同操作，返回数据符合以下规范：<ul>
<li>GET &#x2F;books ：返回资源对象的列表</li>
<li>GET &#x2F;books&#x2F;1 ：返回id为1的单个资源对象</li>
<li>POST &#x2F;boos：返回新生成的资源对象</li>
<li>PUT &#x2F;books&#x2F;1：返回修改后的完整的资源对象</li>
<li>PATCH &#x2F;books&#x2F;1：返回修改后端完整的资源对象</li>
<li>DELETE &#x2F;books&#x2F;1：返回一个空文档</li>
</ul>
</li>
<li>返回结果中写在资源连接：{“name”:”zhangsan”, “url”:”<a target="_blank" rel="noopener" href="http://www.xx.xx.com/xxx%22%7D">http://www.xx.xx.com/xxx&quot;}</a></li>
</ul>
<h3 id="1-3-Django-RESTful介绍与安装"><a href="#1-3-Django-RESTful介绍与安装" class="headerlink" title="1.3 Django-RESTful介绍与安装"></a>1.3 Django-RESTful介绍与安装</h3><h4 id="1-3-1-介绍"><a href="#1-3-1-介绍" class="headerlink" title="1.3.1 介绍"></a>1.3.1 介绍</h4><ul>
<li>Django rest_framework, 简称 drf, 可以更方便的使用django写出符合 RESTful 规范的接口, (缩减编写api接口的代码)</li>
</ul>
<blockquote>
<ul>
<li>Django REST framework是一个建立在Django基础之上的Web应用开发框架(Django的一个app)，可以快速的开发REST API接口应用</li>
<li>在REST framework中，提供了序列化器Serialzier的定义，可以帮助我们简化序列化与反序列化的过程</li>
<li>不仅如此，还提供丰富的类视图、扩展类、视图集来简化视图的编写工作</li>
<li>REST framework还提供了认证、权限、限流、过滤、分页、接口文档等功能支持</li>
<li>REST framework提供了一个API 的Web可视化界面来方便查看测试接口</li>
</ul>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.django-rest-framework.org/">官方文档 : https://www.django-rest-framework.org/</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/encode/django-rest-framework/tree/master">GitHub : https://github.com/encode/django-rest-framework/tree/master</a></li>
</ul>
<h4 id="1-3-2-安装DRF"><a href="#1-3-2-安装DRF" class="headerlink" title="1.3.2 安装DRF"></a>1.3.2 安装DRF</h4><pre><code class="hljs plaintext">pip install djangorestframework</code></pre>

<h4 id="1-3-3-配置DRF"><a href="#1-3-3-配置DRF" class="headerlink" title="1.3.3 配置DRF"></a>1.3.3 配置DRF</h4><p>在settings.py中添加app</p>
<pre><code class="hljs plaintext">INSTALLED_APPS = [
    ...
    &#x27;rest_framework&#x27;,
]</code></pre>

<p>1.3.4 models.py中书写模型类</p>
<pre><code class="hljs plaintext">from django.db import models
class Book(models.Model):
    nid = models.AutoField(primary_key=True)
    title = models.CharField(max_length=32)
    price = models.DecimalField(max_digits=8,decimal_places=2)
    author = models.CharField(max_length=16)
    publish = models.CharField(max_length=16)
    # 创建好模型类执行数据库迁移命令</code></pre>

<h4 id="1-3-4-serializer-py新建一个序列化类（该文件也自己创建）"><a href="#1-3-4-serializer-py新建一个序列化类（该文件也自己创建）" class="headerlink" title="1.3.4 serializer.py新建一个序列化类（该文件也自己创建）"></a>1.3.4 serializer.py新建一个序列化类（该文件也自己创建）</h4><pre><code class="hljs plaintext">from rest_framework.serializers import ModelSerializer
from drf_test import models
class BookSerializers(ModelSerializer):
    class Meta:
        model = models.Book # 指明该序列化器处理的数据字段从模型类Book参考生成
        fields = &quot;__all__&quot; # 指明该序列化器包含模型类中的哪些字段，’all‘指明包含所有字段
</code></pre>

<h4 id="1-3-5-视图类"><a href="#1-3-5-视图类" class="headerlink" title="1.3.5 视图类"></a>1.3.5 视图类</h4><pre><code class="hljs plaintext">from django.shortcuts import render
from rest_framework.viewsets import ModelViewSet
from drf_test.serializers import BookSerializers
from drf_test import models

class BookView(ModelViewSet):
    serializer_class = BookSerializers # 指明该视图在进行序列化或反序列化时使用的序列化器
    queryset = models.Book.objects.all() # 指明该视图集在查询数据时使用的查询集</code></pre>

<h4 id="1-3-6-编写路由"><a href="#1-3-6-编写路由" class="headerlink" title="1.3.6 编写路由"></a>1.3.6 编写路由</h4><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin
<span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path
<span class="hljs-keyword">from</span> rest_framework.routers <span class="hljs-keyword">import</span> SimpleRouter
<span class="hljs-keyword">from</span> drf_test <span class="hljs-keyword">import</span> views
router = SimpleRouter() <span class="hljs-comment"># 用来处理视图的路由器</span>
router.register(<span class="hljs-string">&#x27;book&#x27;</span>,views.BookView) <span class="hljs-comment"># 在路由器中注册视图集</span>
urlpatterns = [
    path(<span class="hljs-string">&#x27;admin/&#x27;</span>, admin.site.urls),
]
urlpatterns += router.urls <span class="hljs-comment"># 将路由器中的所有路由信息拼接到Django中的路由列表中</span></code></pre>

<h4 id="1-3-7-启动项目开始测试"><a href="#1-3-7-启动项目开始测试" class="headerlink" title="1.3.7 启动项目开始测试"></a>1.3.7 启动项目开始测试</h4><p>POST：添加一本书</p>
<p>GET：获取图书</p>
<h2 id="2-DRF功能组件"><a href="#2-DRF功能组件" class="headerlink" title="2 DRF功能组件"></a>2 DRF功能组件</h2><h3 id="2-1-认证Authentication"><a href="#2-1-认证Authentication" class="headerlink" title="2.1 认证Authentication"></a>2.1 认证Authentication</h3><h4 id="2-1-1-认证配置"><a href="#2-1-1-认证配置" class="headerlink" title="2.1.1 认证配置"></a>2.1.1 认证配置</h4><p>在配置文件中配置全局默认的认证方案：</p>
<pre><code class="hljs plaintext">REST_FRAMEWORK = &#123;
    &#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;: (
        &#x27;rest_framework.authentication.BasicAuthentication&#x27;,   # 基本认证
        &#x27;rest_framework.authentication.SessionAuthentication&#x27;,  # session认证
    )
&#125;</code></pre>

<p>也可以在每个视图中通过设置authentication_classes属性来设置</p>
<pre><code class="hljs plaintext">from rest_framework.authentication import SessionAuthentication, BasicAuthentication
from rest_framework.views import APIView

class ExampleView(APIView):
    authentication_classes = (SessionAuthentication, BasicAuthentication)
    ...</code></pre>

<p>认证失败会有两种可能的返回值</p>
<ul>
<li>401 Unauthorized 未认证</li>
<li>403 Permission Denied 权限被禁止</li>
</ul>
<p>权限Permissions</p>
<p>权限控制可以限制用户对于视图的访问和对于具体数据对象的访问。</p>
<ul>
<li>在执行视图的dispatch()方法前，会先进行视图访问权限的判断</li>
<li>在通过get_object()获取具体对象时，会进行模型对象访问权限的判断</li>
</ul>
<h4 id="2-1-2-认证使用"><a href="#2-1-2-认证使用" class="headerlink" title="2.1.2 认证使用"></a>2.1.2 认证使用</h4><p>可以在配置文件中设置默认的权限管理类，如：</p>
<pre><code class="hljs plaintext">REST_FRAMEWORK = &#123;
    &#x27;DEFAULT_PERMISSION_CLASSES&#x27;: (
        &#x27;rest_framework.permissions.IsAuthenticated&#x27;,
    )
&#125;</code></pre>

<p>如果未指明，则采用如下默认配置</p>
<pre><code class="hljs plaintext">&#x27;DEFAULT_PERMISSION_CLASSES&#x27;: (
   &#x27;rest_framework.permissions.AllowAny&#x27;,
)</code></pre>

<p>也可以在具体的视图中通过permission_casses属性来设置，如：</p>
<pre><code class="hljs plaintext">from rest_framework.permissions import IsAuthenticated
from rest_framework.views import APIView

class ExampleView(APIView):
    permission_classes = (IsAuthenticated,)
    ...</code></pre>

<h4 id="2-1-3-提供的权限"><a href="#2-1-3-提供的权限" class="headerlink" title="2.1.3 提供的权限"></a>2.1.3 提供的权限</h4><ul>
<li>AllowAny 允许所有用户</li>
<li>IsAuthenticated 仅通过认证的用户</li>
<li>IsAdminUser 仅管理员用户</li>
<li>IsAuthenticatedOrReadOnly 已经登陆认证的用户可以对数据进行增删改操作，没有登陆认证的只能查看数据。</li>
</ul>
<p>案例：</p>
<pre><code class="hljs plaintext">from rest_framework.authentication import SessionAuthentication
from rest_framework.permissions import IsAuthenticated
from rest_framework.generics import RetrieveAPIView

class BookDetailView(RetrieveAPIView):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer
    authentication_classes = [SessionAuthentication]
    permission_classes = [IsAuthenticated]</code></pre>

<h4 id="2-1-4-自定义权限"><a href="#2-1-4-自定义权限" class="headerlink" title="2.1.4 自定义权限"></a>2.1.4 自定义权限</h4><p>如需自定义权限，需继承rest_framework.permissions.BasePermission父类，并实现以下两个任何一个方法或全部</p>
<ul>
<li><code>.has_permission(self, request, view)</code><br>是否可以访问视图， view表示当前视图对象</li>
<li><code>.has_object_permission(self, request, view, obj)</code><br>是否可以访问数据对象， view表示当前视图， obj为数据对象</li>
</ul>
<p>案例：</p>
<pre><code class="hljs plaintext">class MyPermission(BasePermission):
    def has_object_permission(self, request, view, obj):
        &quot;&quot;&quot;控制对obj对象的访问权限，此案例决绝所有对对象的访问&quot;&quot;&quot;
        return False

class BookInfoViewSet(ModelViewSet):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer
    permission_classes = [IsAuthenticated, MyPermission]</code></pre>

<h3 id="2-2-限流Throttling"><a href="#2-2-限流Throttling" class="headerlink" title="2.2 限流Throttling"></a>2.2 限流Throttling</h3><h4 id="2-2-1-限流介绍"><a href="#2-2-1-限流介绍" class="headerlink" title="2.2.1 限流介绍"></a>2.2.1 限流介绍</h4><p>可以对接口访问的频次进行限制，以减轻服务器压力。</p>
<p>一般用于付费购买次数,投票等场景使用.</p>
<h4 id="2-2-2-限流使用"><a href="#2-2-2-限流使用" class="headerlink" title="2.2.2 限流使用"></a>2.2.2 限流使用</h4><p>可以在配置文件中，使用DEFAULT_THROTTLE_CLASSES和DEFAULT_THROTTLE_RATES进行全局配置</p>
<pre><code class="hljs plaintext">REST_FRAMEWORK = &#123;
    &#x27;DEFAULT_THROTTLE_CLASSES&#x27;: (
        &#x27;rest_framework.throttling.AnonRateThrottle&#x27;,
        &#x27;rest_framework.throttling.UserRateThrottle&#x27;
    ),
    &#x27;DEFAULT_THROTTLE_RATES&#x27;: &#123;
        &#x27;anon&#x27;: &#x27;100/day&#x27;,
        &#x27;user&#x27;: &#x27;1000/day&#x27;
    &#125;
&#125;</code></pre>

<p><code>DEFAULT_THROTTLE_RATES</code> 可以使用 <code>second</code>, <code>minute</code>, <code>hour</code> 或 <code>day</code>来指明周期。</p>
<p>也可以在具体视图中，通过throttle_classes属性来配置，如：</p>
<pre><code class="hljs plaintext">from rest_framework.throttling import UserRateThrottle
from rest_framework.views import APIView

class ExampleView(APIView):
    throttle_classes = (UserRateThrottle,)
    ...</code></pre>

<h4 id="2-2-3-可选限流类"><a href="#2-2-3-可选限流类" class="headerlink" title="2.2.3 可选限流类"></a>2.2.3 可选限流类</h4><p>1） AnonRateThrottle</p>
<p>限制所有匿名未认证用户，使用IP区分用户。</p>
<p>使用 <code>DEFAULT_THROTTLE_RATES[&#39;anon&#39;]</code> 来设置频次</p>
<p>2）UserRateThrottle</p>
<p>限制认证用户，使用User id 来区分。</p>
<p>使用 <code>DEFAULT_THROTTLE_RATES[&#39;user&#39;]</code> 来设置频次</p>
<p>3）ScopedRateThrottle</p>
<p>限制用户对于每个视图的访问频次，使用ip或user id。</p>
<p>例如：</p>
<pre><code class="hljs plaintext">class ContactListView(APIView):
    throttle_scope = &#x27;contacts&#x27;
    ...

class ContactDetailView(APIView):
    throttle_scope = &#x27;contacts&#x27;
    ...

class UploadView(APIView):
    throttle_scope = &#x27;uploads&#x27;
    ...
REST_FRAMEWORK = &#123;
    &#x27;DEFAULT_THROTTLE_CLASSES&#x27;: (
        &#x27;rest_framework.throttling.ScopedRateThrottle&#x27;,
    ),
    &#x27;DEFAULT_THROTTLE_RATES&#x27;: &#123;
        &#x27;contacts&#x27;: &#x27;1000/day&#x27;,
        &#x27;uploads&#x27;: &#x27;20/day&#x27;
    &#125;
&#125;</code></pre>

<h4 id="2-2-4-案例"><a href="#2-2-4-案例" class="headerlink" title="2.2.4 案例"></a>2.2.4 案例</h4><pre><code class="hljs plaintext">from rest_framework.authentication import SessionAuthentication
from rest_framework.permissions import IsAuthenticated
from rest_framework.generics import RetrieveAPIView
from rest_framework.throttling import UserRateThrottle

class BookDetailView(RetrieveAPIView):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer
    authentication_classes = [SessionAuthentication]
    permission_classes = [IsAuthenticated]
    throttle_classes = (UserRateThrottle,)</code></pre>

<h3 id="2-3-过滤Filtering"><a href="#2-3-过滤Filtering" class="headerlink" title="2.3 过滤Filtering"></a>2.3 过滤Filtering</h3><h4 id="2-3-1-基本用法"><a href="#2-3-1-基本用法" class="headerlink" title="2.3.1 基本用法"></a>2.3.1 基本用法</h4><p>对于列表数据，可能需求根据字典及逆行过滤，我们可以通过添加django-filter扩展来增强支持。</p>
<pre><code class="hljs plaintext">pip install django-filter

# 从数据库中查询数据的过滤
select * from t_emp where name=&#x27;zs&#x27; and sal=2000</code></pre>

<p>在配置文件中增加过滤后端的设置</p>
<pre><code class="hljs plaintext">INSTALLED_APPS = [
    ...
    &#x27;django_filters&#x27;,  # 需要注册应用，
]

REST_FRAMEWORK = &#123;
    ...
    &#x27;DEFAULT_FILTER_BACKENDS&#x27;: (&#x27;django_filters.rest_framework.DjangoFilterBackend&#x27;,)
&#125;</code></pre>

<p>在视图中添加filter_fields属性，指定可以过滤的字段</p>
<pre><code class="hljs plaintext">class BookListView(ListAPIView):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer
    filter_fields = (&#x27;btitle&#x27;, &#x27;bread&#x27;)

# 127.0.0.1:8000/books/?btitle=西游记</code></pre>

<h4 id="2-3-2-排序"><a href="#2-3-2-排序" class="headerlink" title="2.3.2 排序"></a>2.3.2 排序</h4><p>对于列表数据，REST framework提供了OrderingFileter过滤器来帮助我们快速指明数据按照指定字段进行排序</p>
<p>用法</p>
<p>在类视图中设置filter_backends，使用 <code>rest_framework.filters.OrderingFilter</code>过滤器，REST framework会在请求的查询字符串参数中检查是否包含了ordering参数，如果包含了ordering参数，则按照ordering参数指明的排序字段对数据集进行排序。</p>
<p>前端可以传递的ordering参数的可选字段值需要在ordering_fields中指明。</p>
<p>示例：</p>
<pre><code class="hljs plaintext">class BookListView(ListAPIView):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer
    filter_backends = [OrderingFilter]
    ordering_fields = (&#x27;id&#x27;, &#x27;bread&#x27;, &#x27;bpub_date&#x27;)

# 127.0.0.1:8000/books/?ordering=-bread</code></pre>

<h3 id="2-4-分页"><a href="#2-4-分页" class="headerlink" title="2.4 分页"></a>2.4 分页</h3><h4 id="2-4-1-基本用法"><a href="#2-4-1-基本用法" class="headerlink" title="2.4.1 基本用法"></a>2.4.1 基本用法</h4><p>REST framework提供了分页的支持。</p>
<p>我们可以在配置文件中设置全局的分页方式，如：</p>
<pre><code class="hljs plaintext">REST_FRAMEWORK = &#123;
    &#x27;DEFAULT_PAGINATION_CLASS&#x27;:  &#x27;rest_framework.pagination.PageNumberPagination&#x27;,
    &#x27;PAGE_SIZE&#x27;: 100  # 每页数目
&#125;</code></pre>

<p>也可以通过自定义Pagination类，来未视图添加不通分页行为。在视图中通过Pagination_clas属性来指明</p>
<pre><code class="hljs plaintext">class LargeResultsSetPagination(PageNumberPagination):
    page_size = 1000
    page_size_query_param = &#x27;page_size&#x27;
    max_page_size = 10000
class BookDetailView(RetrieveAPIView):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer
    pagination_class = LargeResultsSetPagination</code></pre>

<p>注意：如果在视图内关闭分页功能，可以按照下面的代码进行设置</p>
<pre><code class="hljs plaintext">pagination_class = None</code></pre>

<h4 id="2-4-2-可选分页器"><a href="#2-4-2-可选分页器" class="headerlink" title="2.4.2 可选分页器"></a>2.4.2 可选分页器</h4><p>1） <strong>PageNumberPagination</strong></p>
<p>前端访问网址形式：</p>
<pre><code class="hljs plaintext">GET  http://api.example.org/books/?page=4</code></pre>

<p>可以在子类中定义的属性：</p>
<ul>
<li>page_size 每页数目</li>
<li>page_query_param 前端发送的页数关键字名，默认为”page”</li>
<li>page_size_query_param 前端发送的每页数目关键字名，默认为None</li>
<li>max_page_size 前端最多能设置的每页数量</li>
</ul>
<pre><code class="hljs plaintext">from rest_framework.pagination import PageNumberPagination

class StandardPageNumberPagination(PageNumberPagination):
    page_size_query_param = &#x27;page_size&#x27;
    max_page_size = 10

class BookListView(ListAPIView):
    queryset = BookInfo.objects.all().order_by(&#x27;id&#x27;)
    serializer_class = BookInfoSerializer
    pagination_class = StandardPageNumberPagination

# 127.0.0.1/books/?page=1&amp;page_size=2</code></pre>

<p>2）<strong>LimitOffsetPagination</strong></p>
<p>前端访问网址形式：</p>
<pre><code class="hljs plaintext">GET http://api.example.org/books/?limit=100&amp;offset=400</code></pre>

<p>可以在子类中定义的属性：</p>
<ul>
<li>default_limit 默认限制，默认值与 <code>PAGE_SIZE</code>设置一直</li>
<li>limit_query_param limit参数名，默认’limit’</li>
<li>offset_query_param offset参数名，默认’offset’</li>
<li>max_limit 最大limit限制，默认None</li>
</ul>
<pre><code class="hljs plaintext">from rest_framework.pagination import LimitOffsetPagination

class BookListView(ListAPIView):
    queryset = BookInfo.objects.all().order_by(&#x27;id&#x27;)
    serializer_class = BookInfoSerializer
    pagination_class = LimitOffsetPagination

# 127.0.0.1:8000/books/?offset=3&amp;limit=2</code></pre>

<h3 id="2-5-异常处理Exceptions"><a href="#2-5-异常处理Exceptions" class="headerlink" title="2.5 异常处理Exceptions"></a>2.5 异常处理Exceptions</h3><p>REST framework 提供了异常处理，我们可以自定义异常处理函数</p>
<pre><code class="hljs plaintext">from rest_framework.views import exception_handler

def custom_exception_handler(exc, context):
    # 先调用REST framework默认的异常处理方法获得标准错误响应对象
    response = exception_handler(exc, context)

    # 在此处补充自定义的异常处理
    if response is not None:
        response.data[&#x27;status_code&#x27;] = response.status_code

    return response</code></pre>

<p>在配置文件中声明自定义的异常处理</p>
<pre><code class="hljs plaintext">REST_FRAMEWORK = &#123;
    &#x27;EXCEPTION_HANDLER&#x27;: &#x27;my_project.my_app.utils.custom_exception_handler&#x27;
&#125;</code></pre>

<p>如果未声明，会采用默认的方式，如下：</p>
<pre><code class="hljs plaintext">REST_FRAMEWORK = &#123;
    &#x27;EXCEPTION_HANDLER&#x27;: &#x27;rest_framework.views.exception_handler&#x27;
&#125;</code></pre>

<p>例如：</p>
<p>补充上处理关于数据库的异常</p>
<pre><code class="hljs plaintext">from rest_framework.views import exception_handler as drf_exception_handler
from rest_framework import status
from django.db import DatabaseError

def exception_handler(exc, context):
    response = drf_exception_handler(exc, context)

    if response is None:
        view = context[&#x27;view&#x27;]
        if isinstance(exc, DatabaseError):
            print(&#x27;[%s]: %s&#x27; % (view, exc))
            response = Response(&#123;&#x27;detail&#x27;: &#x27;服务器内部错误&#x27;&#125;, status=status.HTTP_507_INSUFFICIENT_STORAGE)

    return response
</code></pre>

<p>REST framework定义的异常</p>
<ul>
<li>APIException 所有异常的父类</li>
<li>ParseError 解析错误</li>
<li>AuthenticationFailed 认证失败</li>
<li>NotAuthenticated 尚未认证</li>
<li>PermissionDenied 权限决绝</li>
<li>NotFound 未找到</li>
<li>MethodNotAllowed 请求方式不支持</li>
<li>NotAcceptable 要获取的数据格式不支持</li>
<li>Throttled 超过限流次数</li>
<li>ValidationError 校验失败</li>
</ul>
<h3 id="2-6-自动生成接口文档"><a href="#2-6-自动生成接口文档" class="headerlink" title="2.6 自动生成接口文档"></a>2.6 自动生成接口文档</h3><p>REST framework可以自动帮助我们生成接口文档。</p>
<p>接口文档以网页的方式呈现。</p>
<p>自动接口文档能生成的是继承自 <code>APIView</code>及其子类的视图。</p>
<h4 id="2-6-1-安装依赖"><a href="#2-6-1-安装依赖" class="headerlink" title="2.6.1 安装依赖"></a>2.6.1 安装依赖</h4><pre><code class="hljs plaintext">pip install coreapi</code></pre>

<h4 id="2-6-2-设置接口文档访问路径"><a href="#2-6-2-设置接口文档访问路径" class="headerlink" title="2.6.2 设置接口文档访问路径"></a>2.6.2 设置接口文档访问路径</h4><p>在总路由中添加接口文档路径。</p>
<p>文档路由对应的视图配置为 <code>rest_framework.documentation.include_docs_urls</code>，</p>
<p>参数 <code>title</code>为接口文档网站的标题。</p>
<pre><code class="hljs plaintext">from rest_framework.documentation import include_docs_urls

urlpatterns = [
    ...
    path(&#x27;docs/&#x27;, include_docs_urls(title=&#x27;站点页面标题&#x27;))
]</code></pre>

<p>需要在配置文件settings.py中指定schema_class的配置</p>
<pre><code class="hljs plaintext">REST_FRAMEWORK = &#123;
    &#x27;DEFAULT_SCHEMA_CLASS&#x27;: &#x27;rest_framework.schemas.coreapi.AutoSchema&#x27;
&#125;</code></pre>

<h4 id="2-6-3-文档描述说明的定义位置"><a href="#2-6-3-文档描述说明的定义位置" class="headerlink" title="2.6.3 文档描述说明的定义位置"></a>2.6.3 文档描述说明的定义位置</h4><p>(1)单一方法的视图，可直接使用类视图的文档字符串，如</p>
<pre><code class="hljs plaintext">class BookListView(generics.ListAPIView):
    &quot;&quot;&quot;
    返回所有图书信息.
    &quot;&quot;&quot;</code></pre>

<p>(2) 包含多个方法的视图，在类视图的文档字符串中，分开方法定义，如：</p>
<pre><code class="hljs plaintext">class BookListCreateView(generics.ListCreateAPIView):
    &quot;&quot;&quot;
    get:
    返回所有图书信息.

    post:
    新建图书.
    &quot;&quot;&quot;</code></pre>

<p>(3) 对于视图集ViewSet，仍在类视图的文档字符串中封开定义，但是应使用action名称区分，如：</p>
<pre><code class="hljs plaintext">class BookInfoViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, GenericViewSet):
    &quot;&quot;&quot;
    list:
    返回图书列表数据

    retrieve:
    返回图书详情数据

    latest:
    返回最新的图书数据

    read:
    修改图书的阅读量
    &quot;&quot;&quot;</code></pre>

<h4 id="2-6-4-访问接口文档网页"><a href="#2-6-4-访问接口文档网页" class="headerlink" title="2.6.4 访问接口文档网页"></a>2.6.4 访问接口文档网页</h4><p>1） 视图集ViewSet中的retrieve名称，在接口文档网站中叫做read</p>
<p>2）参数的Description需要在模型类或序列化器类的字段中以help_text选项定义，如：</p>
<pre><code class="hljs plaintext">class BookInfo(models.Model):
    ...
    bread = models.IntegerField(default=0, verbose_name=&#x27;阅读量&#x27;, help_text=&#x27;阅读量&#x27;)
    ...</code></pre>

<p>或</p>
<pre><code class="hljs plaintext">class BookReadSerializer(serializers.ModelSerializer):
    class Meta:
        model = BookInfo
        fields = (&#x27;bread&#x27;, )
        extra_kwargs = &#123;
            &#x27;bread&#x27;: &#123;
                &#x27;required&#x27;: True,
                &#x27;help_text&#x27;: &#x27;阅读量&#x27;
            &#125;
        &#125;</code></pre>

<h2 id="3-DRF视图家族"><a href="#3-DRF视图家族" class="headerlink" title="3 DRF视图家族"></a>3 DRF视图家族</h2><p>Django REST framwork 提供的视图的主要作用：</p>
<ul>
<li>控制序列化器的执行（检验、保存、转换数据）</li>
<li>控制数据库查询的执行</li>
</ul>
<h3 id="3-1-两个视图基类"><a href="#3-1-两个视图基类" class="headerlink" title="3.1 两个视图基类"></a>3.1 两个视图基类</h3><p>APIView和GenericAPIView</p>
<h4 id="3-1-1-APIView"><a href="#3-1-1-APIView" class="headerlink" title="3.1.1 APIView"></a>3.1.1 APIView</h4><pre><code class="hljs plaintext">rest_framework.views.APIView</code></pre>

<p>APIView是REST framework提供的所有视图的基类，继承自Django的View父类</p>
<p>APIView 与 View 的不同之处在于：</p>
<ul>
<li>传入到视图方法中的是REST framework的 <code>Request</code>对象，而不是Django的 <code>HttpRequeset</code>对象；</li>
<li>视图方法可以返回REST framework的 <code>Response</code>对象，视图会为响应数据设置（render）符合前端要求的格式；</li>
<li>任何 <code>APIException</code>异常都会被捕获到，并且处理成合适的响应信息；</li>
<li>在进行dispatch()分发前，会对请求进行身份认证、权限检查、流量控制。</li>
</ul>
<p>支持定义的属性</p>
<ul>
<li><strong>authentication_classes</strong> 列表或元祖，身份认证类</li>
<li><strong>permissoin_classes</strong> 列表或元祖，权限检查类</li>
<li><strong>throttle_classes</strong> 列表或元祖，流量控制类</li>
</ul>
<p>在 <code>APIView</code>中仍以常规的类视图定义方法来实现get() 、post() 或者其他请求方式的方法。</p>
<p>例如：</p>
<pre><code class="hljs plaintext">from rest_framework.views import APIView
from rest_framework.response import Response

# url(r&#x27;^books/$&#x27;, views.BookListView.as_view()),
class BookListView(APIView):
    def get(self, request):
        books = BookInfo.objects.all()
        serializer = BookInfoSerializer(books, many=True)
        return Response(serializer.data)</code></pre>

<h4 id="3-1-2-GenericAPIView"><a href="#3-1-2-GenericAPIView" class="headerlink" title="3.1.2 GenericAPIView"></a>3.1.2 GenericAPIView</h4><pre><code class="hljs plaintext">rest_framework.generics.GenericAPIView</code></pre>

<p>继承自 <code>APIVIew</code>，主要增加了操作序列化器和数据库查询的方法，作用是为下面Mixin扩展类的执行提供方法支持。通常在使用时，可搭配一个或多个Mixin扩展类。</p>
<p><strong>提供的关于序列化器使用的属性与方法</strong></p>
<ul>
<li><p>属性：</p>
<ul>
<li>serializer_class 指明视图使用的序列化器</li>
</ul>
</li>
<li><p>方法：</p>
<ul>
<li>get_serializer_class(self)<br>当出现一个视图类中调用多个序列化器时，那么可以通过条件来判断在get_serializer_class方法中通过返回不同的序列化器类名就可以让视图方法执行不同的序列化器对象了。<br>返回序列化器类，默认返回serializer_class，可以重写，例如：<pre><code class="hljs plaintext">def get_serializer_class(self):
    if self.request.user.is_staff:
        return FullAccountSerializer
    return BasicAccountSerializer</code></pre></li>
</ul>
</li>
<li><p>get_serializer(self, args, *kwargs)</p>
<p>返回序列化器对象，主要用来提供给Mixin扩展类使用，如果我们在视图中想要获取序列化器对象，也可以直接调用此方法。</p>
<p>注意，该方法在提供序列化器对象的时候，会向序列化器对象的context属性补充三个数据：request、format、view，这三个数据对象可以在定义序列化器时使用。</p>
<ul>
<li>request 当前视图的请求对象</li>
<li>view 当前请求的类视图对象</li>
<li>format 当前请求期望返回的数据格式</li>
</ul>
</li>
</ul>
<p><strong>提供的关于数据库查询的属性与方法</strong></p>
<p>属性：</p>
<ul>
<li>queryset 指明使用的数据查询集</li>
</ul>
<p>方法：</p>
<ul>
<li><p>get_queryset(self)<br>返回视图使用的查询集，主要用来提供给Mixin扩展类使用，是列表视图与详情视图获取数据的基础，默认返回queryset属性，可以重写，例如：</p>
<pre><code class="hljs plaintext">def get_queryset(self):
    user = self.request.user
    return user.accounts.all()</code></pre></li>
<li><p>get_boject(self)</p>
<p>返回详情视图所需的模型类数据对象，主要用来提供给Mixin扩展类使用。<br>在视图中可以调用该方法获取详情信息的模型类对象。<br>若详情访问的模型类对象不存在，会返回404。<br>该方法会默认使用APIView提供的check_object_permissions方法检查当前对象是否有权限被访问。</p>
<p>例如：</p>
<pre><code class="hljs plaintext"># url(r&#x27;^books/(?P&lt;pk&gt;\d+)/$&#x27;, views.BookDetailView.as_view()),
class BookDetailView(GenericAPIView):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer

    def get(self, request, pk):
        book = self.get_object() # get_object()方法根据pk参数查找queryset中的数据对象
        serializer = self.get_serializer(book)
        return Response(serializer.data)</code></pre></li>
</ul>
<p>其他可以设置的属性</p>
<ul>
<li><strong>pagination_class</strong> 指明分页控制类</li>
<li><strong>filter_backends</strong> 指明过滤控制后端</li>
</ul>
<h4 id="3-1-3-DRF的请求对象"><a href="#3-1-3-DRF的请求对象" class="headerlink" title="3.1.3 DRF的请求对象"></a>3.1.3 DRF的请求对象</h4><p>REST framework 传入视图的request对象不再是Django默认的HttpRequest对象，而是REST framework提供的扩展了HttpRequest类的<strong>Request</strong>类的对象。</p>
<p>REST framework 提供了<strong>Parser</strong>解析器，在接收到请求后会自动根据Content-Type指明的请求数据类型（如JSON、表单等）将请求数据进行parse解析，解析为类字典[QueryDict]对象保存到<strong>Request</strong>对象中。</p>
<h5 id="1）-data"><a href="#1）-data" class="headerlink" title="1）.data"></a>1）.data</h5><p><code>request.data</code> 返回解析之后的请求体数据。类似于Django中标准的 <code>request.POST</code>和 <code>request.FILES</code>属性，但提供如下特性：</p>
<ul>
<li>包含了解析之后的文件和非文件数据</li>
<li>包含了对POST、PUT、PATCH请求方式解析后的数据</li>
<li>利用了REST framework的parsers解析器，不仅支持表单类型数据，也支持JSON数据</li>
</ul>
<h5 id="2）-query-params"><a href="#2）-query-params" class="headerlink" title="2）.query_params"></a>2）.query_params</h5><p><code>request.query_params</code>与Django标准的 <code>request.GET</code>相同，只是更换了更正确的名称而已。</p>
<h5 id="3）request-request"><a href="#3）request-request" class="headerlink" title="3）request._request"></a>3）request._request</h5><p>获取django封装的Request对象</p>
<p><strong>注意：要使用drf提供的Request请求处理对象，必须在编写视图类时继承drf提供的视图基类<br>from rest_framework.views import APIView</strong></p>
<h4 id="3-1-4-DRF的响应对象"><a href="#3-1-4-DRF的响应对象" class="headerlink" title="3.1.4 DRF的响应对象"></a>3.1.4 DRF的响应对象</h4><p>REST framework提供了一个响应类 <code>Response</code>，使用该类构造响应对象时，响应的具体数据内容会被转换（render渲染器）成符合前端需求的类型。</p>
<p>REST framework提供了 <code>Renderer</code> 渲染器，用来根据请求头中的 <code>Accept</code>（接收数据类型声明）来自动转换响应数据到对应格式。如果前端请求中未进行Accept声明，则会采用Content-Type方式处理响应数据，我们可以通过配置来修改默认响应格式。</p>
<p>可以在<strong>rest_framework.settings</strong>查找所有的drf默认配置项</p>
<pre><code class="hljs plaintext">REST_FRAMEWORK = &#123;
    &#x27;DEFAULT_RENDERER_CLASSES&#x27;: (  # 默认响应渲染类
        &#x27;rest_framework.renderers.JSONRenderer&#x27;,  # json渲染器，返回json数据
        &#x27;rest_framework.renderers.BrowsableAPIRenderer&#x27;,  # 浏览器API渲染器，返回调试界面
    )
&#125;</code></pre>

<h5 id="1）response的构造方式"><a href="#1）response的构造方式" class="headerlink" title="1）response的构造方式"></a>1）response的构造方式</h5><p>Response(data, status&#x3D;None, template_name&#x3D;None, headers&#x3D;None, content_type&#x3D;None)</p>
<p><code>data</code>数据不要是render处理之后的数据，只需传递python的内建类型数据即可，REST framework会使用 <code>renderer</code>渲染器处理 <code>data</code>。</p>
<p><code>data</code>不能是复杂结构的数据，如Django的模型类对象，对于这样的数据我们可以使用 <code>Serializer</code>序列化器序列化处理后（转为了Python字典类型）再传递给 <code>data</code>参数。</p>
<p>参数说明：</p>
<blockquote>
<ul>
<li><code>data</code>: 为响应准备的序列化处理后的数据；</li>
<li><code>status</code>: 状态码，默认200；</li>
<li><code>template_name</code>: 模板名称，如果使用 <code>HTMLRenderer</code> 时需指明；</li>
<li><code>headers</code>: 用于存放响应头信息的字典；</li>
<li><code>content_type</code>: 响应数据的Content-Type，通常此参数无需传递，REST framework会根据前端所需类型数据来设置该参数</li>
</ul>
</blockquote>
<h5 id="2）response对象的状态码"><a href="#2）response对象的状态码" class="headerlink" title="2）response对象的状态码"></a>2）response对象的状态码</h5><p>为了方便设置状态码，REST framewrok在 <code>rest_framework.status</code>模块中提供了常用http状态码的常量。</p>
<pre><code class="hljs plaintext"># 1）信息告知 - 1xx
HTTP_100_CONTINUE
HTTP_101_SWITCHING_PROTOCOLS

# 2）成功 - 2xx
HTTP_200_OK
HTTP_201_CREATED
HTTP_202_ACCEPTED
HTTP_203_NON_AUTHORITATIVE_INFORMATION
HTTP_204_NO_CONTENT
HTTP_205_RESET_CONTENT
HTTP_206_PARTIAL_CONTENT
HTTP_207_MULTI_STATUS

# 3）重定向 - 3xx
HTTP_300_MULTIPLE_CHOICES
HTTP_301_MOVED_PERMANENTLY
HTTP_302_FOUND
HTTP_303_SEE_OTHER
HTTP_304_NOT_MODIFIED
HTTP_305_USE_PROXY
HTTP_306_RESERVED
HTTP_307_TEMPORARY_REDIRECT

# 4）客户端错误 - 4xx
HTTP_400_BAD_REQUEST
HTTP_401_UNAUTHORIZED
HTTP_402_PAYMENT_REQUIRED
HTTP_403_FORBIDDEN
HTTP_404_NOT_FOUND
HTTP_405_METHOD_NOT_ALLOWED
HTTP_406_NOT_ACCEPTABLE
HTTP_407_PROXY_AUTHENTICATION_REQUIRED
HTTP_408_REQUEST_TIMEOUT
HTTP_409_CONFLICT
HTTP_410_GONE
HTTP_411_LENGTH_REQUIRED
HTTP_412_PRECONDITION_FAILED
HTTP_413_REQUEST_ENTITY_TOO_LARGE
HTTP_414_REQUEST_URI_TOO_LONG
HTTP_415_UNSUPPORTED_MEDIA_TYPE
HTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE
HTTP_417_EXPECTATION_FAILED
HTTP_422_UNPROCESSABLE_ENTITY
HTTP_423_LOCKED
HTTP_424_FAILED_DEPENDENCY
HTTP_428_PRECONDITION_REQUIRED
HTTP_429_TOO_MANY_REQUESTS
HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE
HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS

# 5）服务器错误 - 5xx
HTTP_500_INTERNAL_SERVER_ERROR
HTTP_501_NOT_IMPLEMENTED
HTTP_502_BAD_GATEWAY
HTTP_503_SERVICE_UNAVAILABLE
HTTP_504_GATEWAY_TIMEOUT
HTTP_505_HTTP_VERSION_NOT_SUPPORTED
HTTP_507_INSUFFICIENT_STORAGE
HTTP_511_NETWORK_AUTHENTICATION_REQUIRED</code></pre>

<h4 id="3-1-5-视图类源码解析"><a href="#3-1-5-视图类源码解析" class="headerlink" title="3.1.5 视图类源码解析"></a>3.1.5 视图类源码解析</h4><h5 id="1、View类的源码解析"><a href="#1、View类的源码解析" class="headerlink" title="1、View类的源码解析"></a>1、View类的源码解析</h5><p>View类核心代码在as_view和dispatch方法中，其中as_view是类方法（@classonlymethod），只能通过类调用，不能通过对象调用，它是类视图的入口点。注意这里调用的时候是通过类名.as_view()调用的。</p>
<p>其中，as_view方法主要执行逻辑：</p>
<pre><code class="hljs plaintext"># path(&#x27;books/&#x27;, views.BookViwe.as_view())
# views.BookViwe.as_view()的执行结果，是函数内存地址----》view这个函数的内存地址
# 请求来了---》路由匹配成功----》会执行 这个函数---》view(request)
# view----》self.dispatch(request)</code></pre>

<pre><code class="hljs python"><span class="hljs-meta">@classonlymethod</span>
 <span class="hljs-keyword">def</span> <span class="hljs-title function_">as_view</span>(<span class="hljs-params">cls, **initkwargs</span>):
     <span class="hljs-string">&quot;&quot;&quot;Main entry point for a request-response process.&quot;&quot;&quot;</span>
     <span class="hljs-comment"># 参数检查</span>
     <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> initkwargs:
     	<span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> cls.http_method_names: <span class="hljs-comment"># 参数名不能是指定http的方法名</span>
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;You tried to pass in the %s method name as a &quot;</span>
             <span class="hljs-string">&quot;keyword argument to %s(). Don&#x27;t do that.&quot;</span>
             % (key, cls.__name__))
  
      	<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(cls, key): <span class="hljs-comment"># 参数名必须是类已有属性</span>
 			<span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;%s() received an invalid keyword %r. as_view &quot;</span>
 				<span class="hljs-string">&quot;only accepts arguments that are already &quot;</span>
 				<span class="hljs-string">&quot;attributes of the class.&quot;</span> % (cls.__name__, key))

    <span class="hljs-comment"># 视图处理函数</span>
     <span class="hljs-keyword">def</span> <span class="hljs-title function_">view</span>(<span class="hljs-params">request, *args, **kwargs</span>):
        self = cls(**initkwargs) <span class="hljs-comment"># 实例化当前类的对象</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(self, <span class="hljs-string">&#x27;get&#x27;</span>) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(self, <span class="hljs-string">&#x27;head&#x27;</span>):
            self.head = self.get
        self.setup(request, *args, **kwargs)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(self, <span class="hljs-string">&#x27;request&#x27;</span>):
             <span class="hljs-keyword">raise</span> AttributeError(
             <span class="hljs-string">&quot;%s instance has no &#x27;request&#x27; attribute. Did you override &quot;</span>
             <span class="hljs-string">&quot;setup() and forget to call super()?&quot;</span> % cls.__name__
             )
        <span class="hljs-comment"># 方法派发</span>
        <span class="hljs-keyword">return</span> self.dispatch(request, *args, **kwargs)
     view.view_class = cls
     view.view_initkwargs = initkwargs
  
     <span class="hljs-comment"># take name and docstring from class</span>
     update_wrapper(view, cls, updated=())
     <span class="hljs-comment"># and possible attributes set by decorators</span>
     <span class="hljs-comment"># like csrf_exempt from dispatch</span>
     update_wrapper(view, cls.dispatch, assigned=())
     <span class="hljs-keyword">return</span> view <span class="hljs-comment"># 返回视图函数</span>
</code></pre>

<p>整个as_view方法是一个装饰器函数，它返回内部函数view，所以as_view()执行其实就是内部函数view执行。内部函数view主要逻辑就是：as_view()&#x3D;&gt;view()&#x3D;&gt;dispatch()&#x3D;&gt;相应的http方法</p>
<p>dispatch方法是实例函数，它的主要代码：</p>
<pre><code class="hljs python"><span class="hljs-comment"># dispatch---》你是什么请求，就会执行视图类中请求名字的方法</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):
     <span class="hljs-comment">#检查请求方法是不是在http_method_names中包含</span>
     <span class="hljs-comment">#http_method_names包括八种方法：[&#x27;get&#x27;, &#x27;post&#x27;, &#x27;put&#x27;, &#x27;patch&#x27;, &#x27;delete&#x27;, &#x27;head&#x27;, </span>
     <span class="hljs-comment">#&#x27;options&#x27;, &#x27;trace&#x27;]</span>
     <span class="hljs-keyword">if</span> request.method.lower() <span class="hljs-keyword">in</span> self.http_method_names:
    	 handler = <span class="hljs-built_in">getattr</span>(self, request.method.lower(), self.http_method_not_allowed)
     <span class="hljs-keyword">else</span>: <span class="hljs-comment">#不在调用http_method_not_allowed报错</span>
     	handler = self.http_method_not_allowed
     <span class="hljs-comment">#调用和请求方法同名的实例方法处理用户请求，实例方法需要用户自己定义</span>
     <span class="hljs-keyword">return</span> handler(request, *args, **kwargs)

</code></pre>

<p><strong>总结</strong>：</p>
<p>dispatch主要完成http请求方法的派发，调用视图类对应实例方法处理用户请求，所有用户需要定义和http请求方法同名的实例方法完成功能，所以一般CBV的模块写法是：</p>
<p>所以：django的CBV本质上来说就是FBV</p>
<pre><code class="hljs python"><span class="hljs-keyword">from</span> django.views <span class="hljs-keyword">import</span> View

<span class="hljs-keyword">class</span> <span class="hljs-title class_">IndexView</span>(<span class="hljs-title class_ inherited__">View</span>):
 <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self,request</span>):
 	<span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;get&quot;</span>)
 <span class="hljs-keyword">def</span> <span class="hljs-title function_">post</span>(<span class="hljs-params">self,request</span>):
 	<span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;post&quot;</span>)
 <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self,request</span>):
 	<span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;put&quot;</span>)
 <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">self,request</span>):
 	<span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;delete&quot;</span>)
</code></pre>

<h5 id="2、APIView源码解析"><a href="#2、APIView源码解析" class="headerlink" title="2、APIView源码解析"></a>2、APIView源码解析</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/482/1659679413054/b24df2eff5c841d0bec870cfdde2f951.png" alt="image.png"></p>
<p><strong>as_view()源码：</strong></p>
<pre><code class="hljs python">
<span class="hljs-meta">@classmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">as_view</span>(<span class="hljs-params">cls, **initkwargs</span>):
        <span class="hljs-comment"># 如果他是QuerySet的一个实例</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(<span class="hljs-built_in">getattr</span>(cls, <span class="hljs-string">&#x27;queryset&#x27;</span>, <span class="hljs-literal">None</span>), models.query.QuerySet):
            <span class="hljs-keyword">def</span> <span class="hljs-title function_">force_evaluation</span>():
                <span class="hljs-comment"># 翻译：不要直接计算“.queryset”属性，因为结果将被缓存并在请求之间重用请改用“.all（）”或调用“.get_queryset（）”</span>
                <span class="hljs-keyword">raise</span> RuntimeError(
                    <span class="hljs-string">&#x27;Do not evaluate the `.queryset` attribute directly, &#x27;</span>
                    <span class="hljs-string">&#x27;as the result will be cached and reused between requests. &#x27;</span>
                    <span class="hljs-string">&#x27;Use `.all()` or call `.get_queryset()` instead.&#x27;</span>
                )
            <span class="hljs-comment"># 强制性把属性拿过来</span>
            cls.queryset._fetch_all = force_evaluation
  
	<span class="hljs-comment"># 该走这里了，调用父类的as_view() --- 父类的as_view()核心是dispatch()  &gt;&gt; 跳转到dispatch()</span>
        view = <span class="hljs-built_in">super</span>().as_view(**initkwargs)
        view.cls = cls
        view.initkwargs = initkwargs

        <span class="hljs-comment"># Note: session based authentication is explicitly CSRF validated,</span>
        <span class="hljs-comment"># all other authentication is CSRF exempt.</span>
  
        <span class="hljs-comment"># 豁免csrf检测, 返回view</span>
        <span class="hljs-keyword">return</span> csrf_exempt(view)	 <span class="hljs-comment"># 函数里面套函数，这个一个装饰器！！！</span>
</code></pre>

<p><strong>dispatch()源码</strong></p>
<p>源代码代码步骤</p>
<ol>
<li>记录各个参数</li>
<li>initializer_request()</li>
<li>initial  加载各种中间件</li>
<li>根据得到的请求方法去处理，或处理异常</li>
<li>最后统一处理response</li>
</ol>
<pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):
        <span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">        `.dispatch()` is pretty much the same as Django&#x27;s regular dispatch,</span>
<span class="hljs-string">        but with extra hooks for startup, finalize, and exception handling.</span>
<span class="hljs-string">        &quot;&quot;&quot;</span>
        self.args = args
        self.kwargs = kwargs
        <span class="hljs-comment"># 跳转看一看 &gt;&gt; initializer_request()</span>
        request = self.initialize_request(request, *args, **kwargs)
  
        self.request = request
        self.headers = self.default_response_headers  <span class="hljs-comment"># deprecate?</span>

        <span class="hljs-keyword">try</span>:
            <span class="hljs-comment"># 再跳一跳 &gt;&gt; initial()</span>
            self.initial(request, *args, **kwargs)

            <span class="hljs-comment"># Get the appropriate handler method</span>
            <span class="hljs-comment"># 根据请求方法名字去处理</span>
            <span class="hljs-keyword">if</span> request.method.lower() <span class="hljs-keyword">in</span> self.http_method_names:
                handler = <span class="hljs-built_in">getattr</span>(self, request.method.lower(),
                                  self.http_method_not_allowed)
            <span class="hljs-keyword">else</span>:
                handler = self.http_method_not_allowed

            response = handler(request, *args, **kwargs)
	<span class="hljs-comment"># 异常处理机制</span>
        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> exc:
            response = self.handle_exception(exc)
	<span class="hljs-comment"># 统一处理</span>
        self.response = self.finalize_response(request, response, *args, **kwargs)
        <span class="hljs-keyword">return</span> self.response</code></pre>

<p><strong>initialize_request() 源码</strong></p>
<pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">initialize_request</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):
        <span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">        Returns the initial request object.</span>
<span class="hljs-string">        &quot;&quot;&quot;</span>
        <span class="hljs-comment"># 解析上下文</span>
        parser_context = self.get_parser_context(request)
  
	<span class="hljs-comment"># 构建了一个新的request</span>
        <span class="hljs-keyword">return</span> Request(
            request,
            parsers=self.get_parsers(),
            authenticators=self.get_authenticators(),
            negotiator=self.get_content_negotiator(),
            parser_context=parser_context
        )</code></pre>

<p><strong>initial(): 源码</strong></p>
<p>步骤：</p>
<ul>
<li>获取格式化后缀</li>
<li>设置并执行内容协商</li>
<li>设置并进行   决策版本，确定版本</li>
<li>执行认证（重点）</li>
<li>检查权限</li>
<li>检查限流</li>
</ul>
<pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">initial</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):
        <span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">        Runs anything that needs to occur prior to calling the method handler.</span>
<span class="hljs-string">        &quot;&quot;&quot;</span>
        <span class="hljs-comment"># 获取格式化的后缀</span>
        self.format_kwarg = self.get_format_suffix(**kwargs)

        <span class="hljs-comment"># Perform content negotiation and store the accepted info on the request</span>
        <span class="hljs-comment"># 设置内容协商并存储请求中已接受的信息</span>
        neg = self.perform_content_negotiation(request)
        <span class="hljs-comment"># 执行</span>
        request.accepted_renderer, request.accepted_media_type = neg

        <span class="hljs-comment"># Determine the API version, if versioning is in use.</span>
        <span class="hljs-comment"># 设置决策版本</span>
        version, scheme = self.determine_version(request, *args, **kwargs)
        <span class="hljs-comment"># 执行确定版本</span>
        request.version, request.versioning_scheme = version, scheme

        <span class="hljs-comment"># Ensure that the incoming request is permitted</span>
        <span class="hljs-comment"># 执行认证，检查权限，检查限流</span>
        self.perform_authentication(request)
        self.check_permissions(request)
        self.check_throttles(request)</code></pre>

<h5 id="3、GenericAPIView源码解析"><a href="#3、GenericAPIView源码解析" class="headerlink" title="3、GenericAPIView源码解析"></a>3、GenericAPIView源码解析</h5><p><code>GenericAPIView</code>继承自 <code>APIView</code>，也就是在 <code>APIView</code>基础上再做了一层封装</p>
<p><strong>类属性</strong></p>
<ol>
<li>queryset &#x3D; None</li>
<li>serializer_class &#x3D; None</li>
<li>lookup_field &#x3D; ‘pk’</li>
<li>lookup_url_kwarg &#x3D; None</li>
<li>filter_backends &#x3D; api_settings.DEFAULT_FILTER_BACKENDS</li>
<li>pagination_class &#x3D; api_settings.DEFAULT_PAGINATION_CLASS</li>
</ol>
<p><strong>queryset</strong><br>  queryset是用来控制视图返回给前端的数据。如果没什么逻辑，可以直接写在视图的类属性中，如果逻辑比较复杂，也可以重写get_queryset方法用来返回一个queryset对象。如果重写了get_queryset，那么以后获取queryset的时候就需要通过调用get_queryset方法。因为queryset&#96; 这个属性只会调用一次，以后所有的请求都是使用他的缓存。</p>
<p><strong>serializer_class</strong><br>  serializer_class用来验证和序列化、反序列化数据的。也是可以通过直接设置这个属性，也可以通过重写get_serializer_class来实现。</p>
<p><strong>lookup_field</strong><br>在检索的时候，根据什么参数进行检索。默认是pk，也就是主键。</p>
<p><strong>lookup_url_kwarg</strong><br>在检索的url中的参数名称。默认没有设置，跟lookup_field保持一致。</p>
<p><strong>filter_backends</strong><br>用于过滤查询集的过滤器后端类的列表。默认值与DEFAULT_FILTER_BACKENDS 设置的值相同。</p>
<p><strong>pagination_class</strong><br>当分页列出结果时应使用的分页类。默认值与 DEFAULT_PAGINATION_CLASS 设置的值相同，即 ‘rest_framework.pagination.PageNumberPagination’。</p>
<p><strong>方法</strong></p>
<ol>
<li>get_queryset</li>
<li>get_object</li>
<li>get_serializer</li>
<li>get_serializer_class</li>
<li>get_serializer_context</li>
<li>filter_queryset</li>
</ol>
<p><strong>get_queryset</strong></p>
<p><code>get_queryset</code>默认是返回数据库全部数据，如果想返回其他数据，需要自定义</p>
<pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_queryset</span>(<span class="hljs-params">self</span>):
    <span class="hljs-comment"># 断言queryset是否不为None</span>
    <span class="hljs-keyword">assert</span> self.queryset <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>, (
        <span class="hljs-string">&quot;&#x27;%s&#x27; should either include a `queryset` attribute, &quot;</span>
        <span class="hljs-string">&quot;or override the `get_queryset()` method.&quot;</span>
        % self.__class__.__name__
    )
  
    <span class="hljs-comment"># 定义queryset属性，获取父类的queryset，如果父类没有定义类属性`queryset`，那么默认值就是None，就会报上面断言的错误 </span>
    queryset = self.queryset
    <span class="hljs-comment"># 如果queryset是QuerySet对象，那么返回全部内容</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(queryset, QuerySet):
        queryset = queryset.<span class="hljs-built_in">all</span>()
    <span class="hljs-comment"># 如果不是queryset，那么直接返回</span>
    <span class="hljs-keyword">return</span> queryset</code></pre>

<p><strong>get_object</strong></p>
<p>该方法是用于在数据检索(通过pk查找)的时候，返回一条数据的。</p>
<pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_object</span>(<span class="hljs-params">self</span>):
    queryset = self.filter_queryset(self.get_queryset())
  
    <span class="hljs-comment"># 查找过滤的条件，默认是pk</span>
    lookup_url_kwarg = self.lookup_url_kwarg <span class="hljs-keyword">or</span> self.lookup_field
 
    <span class="hljs-keyword">assert</span> lookup_url_kwarg <span class="hljs-keyword">in</span> self.kwargs, (
        <span class="hljs-string">&#x27;Expected view %s to be called with a URL keyword argument &#x27;</span>
        <span class="hljs-string">&#x27;named &quot;%s&quot;. Fix your URL conf, or set the `.lookup_field` &#x27;</span>
        <span class="hljs-string">&#x27;attribute on the view correctly.&#x27;</span> %
        (self.__class__.__name__, lookup_url_kwarg)
    )
  
    filter_kwargs = &#123;self.lookup_field: self.kwargs[lookup_url_kwarg]&#125;
    obj = get_object_or_404(queryset, **filter_kwargs)
  
    <span class="hljs-comment"># 可能会引发权限被拒绝</span>
    self.check_object_permissions(self.request, obj)
 
    <span class="hljs-keyword">return</span> obj</code></pre>

<p><strong>get_serializer</strong></p>
<p>返回应该用于验证和反序列化输入以及序列化输出的序列化器实例</p>
<p><strong>get_serializer_class</strong></p>
<p>返回用于序列化的类。默认使用 <code>self.serializer_class</code>。如果您需要根据传入请求提供不同的序列化，您可能需要重写它。</p>
<h3 id="3-2-5个视图扩展类"><a href="#3-2-5个视图扩展类" class="headerlink" title="3.2  5个视图扩展类"></a>3.2  5个视图扩展类</h3><p>作用：</p>
<p>提供了几种后端视图（对数据资源进行曾删改查）处理流程的实现，如果需要编写的视图属于这五种，则视图可以通过继承相应的扩展类来复用代码，减少自己编写的代码量。</p>
<p>这五个扩展类需要搭配GenericAPIView父类，因为五个扩展类的实现需要调用GenericAPIView提供的序列化器与数据库查询的方法。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/482/1620998133146189824/ff12dc5e8ed14ea99c68f01278ddbe69.png" alt="image.png"></p>
<h4 id="1-ListModeMixin"><a href="#1-ListModeMixin" class="headerlink" title="(1) ListModeMixin"></a>(1) ListModeMixin</h4><p>列表视图扩展类，提供 <code>list(request, *args, **kwargs)</code>方法快速实现列表视图，返回200状态码。</p>
<p>该Mixin的list方法会对数据进行过滤和分页。</p>
<p>源代码：</p>
<pre><code class="hljs plaintext">class ListModelMixin(object):
    &quot;&quot;&quot;
    List a queryset.
    &quot;&quot;&quot;
    def list(self, request, *args, **kwargs):
        # 过滤
        queryset = self.filter_queryset(self.get_queryset())
        # 分页
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        # 序列化
        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)</code></pre>

<p>例如：</p>
<pre><code class="hljs plaintext">from rest_framework.mixins import ListModelMixin

class BookListView(ListModelMixin, GenericAPIView):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer

    def get(self, request):
        return self.list(request)</code></pre>

<h4 id="2-CreateModeMixin"><a href="#2-CreateModeMixin" class="headerlink" title="(2) CreateModeMixin"></a>(2) CreateModeMixin</h4><p>创建视图扩展类，提供 <code>create(request, *args, **kwargs)</code>方法快速实现创建资源的视图，成功返回201状态码。</p>
<p>如果序列化器对前端发送的数据验证失败，返回400错误。</p>
<p>源代码：</p>
<pre><code class="hljs plaintext">class CreateModelMixin(object):
    &quot;&quot;&quot;
    Create a model instance.
    &quot;&quot;&quot;
    def create(self, request, *args, **kwargs):
        # 获取序列化器
        serializer = self.get_serializer(data=request.data)
        # 验证
        serializer.is_valid(raise_exception=True)
        # 保存
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)

    def perform_create(self, serializer):
        serializer.save()

    def get_success_headers(self, data):
        try:
            return &#123;&#x27;Location&#x27;: str(data[api_settings.URL_FIELD_NAME])&#125;
        except (TypeError, KeyError):
            return &#123;&#125;</code></pre>

<h4 id="3-RetrieveModelMixin"><a href="#3-RetrieveModelMixin" class="headerlink" title="(3) RetrieveModelMixin"></a>(3) RetrieveModelMixin</h4><p>详情视图扩展类，提供 <code>retrieve(request, *args, **kwargs)</code>方法，可以快速实现返回一个存在的数据对象。</p>
<p>如果存在，返回200， 否则返回404。</p>
<p>源代码：</p>
<pre><code class="hljs plaintext">class RetrieveModelMixin(object):
    &quot;&quot;&quot;
    Retrieve a model instance.
    &quot;&quot;&quot;
    def retrieve(self, request, *args, **kwargs):
        # 获取对象，会检查对象的权限
        instance = self.get_object()
        # 序列化
        serializer = self.get_serializer(instance)
        return Response(serializer.data)</code></pre>

<p>例如：</p>
<pre><code class="hljs plaintext">class BookDetailView(RetrieveModelMixin, GenericAPIView):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer

    def get(self, request, pk):
        return self.retrieve(request)</code></pre>

<h4 id="4-UpdateModelMixin"><a href="#4-UpdateModelMixin" class="headerlink" title="(4) UpdateModelMixin"></a>(4) UpdateModelMixin</h4><p>更新视图扩展类，提供 <code>update(request, *args, **kwargs)</code>方法，可以快速实现更新一个存在的数据对象。</p>
<p>同时也提供 <code>partial_update(request, *args, **kwargs)</code>方法，可以实现局部更新。</p>
<p>成功返回200，序列化器校验数据失败时，返回400错误。</p>
<p>源代码：</p>
<pre><code class="hljs plaintext">class UpdateModelMixin(object):
    &quot;&quot;&quot;
    Update a model instance.
    &quot;&quot;&quot;
    def update(self, request, *args, **kwargs):
        partial = kwargs.pop(&#x27;partial&#x27;, False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=request.data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

        if getattr(instance, &#x27;_prefetched_objects_cache&#x27;, None):
            # If &#x27;prefetch_related&#x27; has been applied to a queryset, we need to
            # forcibly invalidate the prefetch cache on the instance.
            instance._prefetched_objects_cache = &#123;&#125;

        return Response(serializer.data)

    def perform_update(self, serializer):
        serializer.save()

    def partial_update(self, request, *args, **kwargs):
        kwargs[&#x27;partial&#x27;] = True
        return self.update(request, *args, **kwargs)</code></pre>

<h4 id="5-DestroyModelMixin"><a href="#5-DestroyModelMixin" class="headerlink" title="(5) DestroyModelMixin"></a>(5) DestroyModelMixin</h4><p>删除视图扩展类，提供 <code>destroy(request, *args, **kwargs)</code>方法，可以快速实现删除一个存在的数据对象。</p>
<p>成功返回204，不存在返回404。</p>
<p>源代码：</p>
<pre><code class="hljs plaintext">class DestroyModelMixin(object):
    &quot;&quot;&quot;
    Destroy a model instance.
    &quot;&quot;&quot;
    def destroy(self, request, *args, **kwargs):
        instance = self.get_object()
        self.perform_destroy(instance)
        return Response(status=status.HTTP_204_NO_CONTENT)

    def perform_destroy(self, instance):
        instance.delete()</code></pre>

<h3 id="3-3-几个子类视图"><a href="#3-3-几个子类视图" class="headerlink" title="3.3 几个子类视图"></a>3.3 几个子类视图</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/482/1620998133146189824/41ee2cb258b6458c9982f10787f98c3b.png" alt="image.png"></p>
<h4 id="1）CreateAPIView"><a href="#1）CreateAPIView" class="headerlink" title="(1）CreateAPIView"></a>(1）CreateAPIView</h4><p>提供 post 方法</p>
<p>继承自： GenericAPIView、CreateModelMixin</p>
<h4 id="2）ListAPIView"><a href="#2）ListAPIView" class="headerlink" title="(2）ListAPIView"></a>(2）ListAPIView</h4><p>提供 get 方法</p>
<p>继承自：GenericAPIView、ListModelMixin</p>
<h4 id="3）RetrieveAPIView"><a href="#3）RetrieveAPIView" class="headerlink" title="(3）RetrieveAPIView"></a>(3）RetrieveAPIView</h4><p>提供 get 方法</p>
<p>继承自: GenericAPIView、RetrieveModelMixin</p>
<h4 id="4）DestoryAPIView"><a href="#4）DestoryAPIView" class="headerlink" title="(4）DestoryAPIView"></a>(4）DestoryAPIView</h4><p>提供 delete 方法</p>
<p>继承自：GenericAPIView、DestoryModelMixin</p>
<h4 id="5）UpdateAPIView"><a href="#5）UpdateAPIView" class="headerlink" title="(5）UpdateAPIView"></a>(5）UpdateAPIView</h4><p>提供 put 和 patch 方法</p>
<p>继承自：GenericAPIView、UpdateModelMixin</p>
<h4 id="6）RetrieveUpdateAPIView"><a href="#6）RetrieveUpdateAPIView" class="headerlink" title="6）RetrieveUpdateAPIView"></a>6）RetrieveUpdateAPIView</h4><p>提供 get、put、patch方法</p>
<p>继承自： GenericAPIView、RetrieveModelMixin、UpdateModelMixin</p>
<h4 id="7）RetrieveUpdateDestoryAPIView"><a href="#7）RetrieveUpdateDestoryAPIView" class="headerlink" title="7）RetrieveUpdateDestoryAPIView"></a>7）RetrieveUpdateDestoryAPIView</h4><p>提供 get、put、patch、delete方法</p>
<p>继承自：GenericAPIView、RetrieveModelMixin、UpdateModelMixin、DestoryModelMixin</p>
<h3 id="3-4-视图集ViewSet"><a href="#3-4-视图集ViewSet" class="headerlink" title="3.4 视图集ViewSet"></a>3.4 视图集ViewSet</h3><p>为了让视图代码变得更加简短,让操作同一个模型的视图方法写在一个视图类中, drf提供了视图集[viewsets]。</p>
<ul>
<li><strong>1.视图集允许开发者自定义类视图方法名</strong></li>
<li><strong>2.视图集允许一个类分配多个不同的路由</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/482/1620998133146189824/a8176780480a4aefbcb0873a7eebc9c9.png" alt="image.png"></p>
<h4 id="3-4-1-常用视图集父类"><a href="#3-4-1-常用视图集父类" class="headerlink" title="3.4.1 常用视图集父类"></a>3.4.1 常用视图集父类</h4><p>(1) ViewSet</p>
<pre><code class="hljs plaintext">继承自APIView与ViewSetMixin，作用也与APIView基本类似，提供了身份认证、权限校验、流量管理等。

ViewSet主要通过继承ViewSetMixin来实现在调用as_view()时传入字典（如&#123;&#x27;get&#x27;:&#x27;list&#x27;&#125;）的映射处理工作。

在ViewSet中，没有提供任何动作action方法，需要我们自己实现action方法。</code></pre>

<p>(2) GenericViewSet</p>
<pre><code class="hljs plaintext">使用ViewSet通常并不方便，因为list、retrieve、create、update、destory等方法都需要自己编写，而这些方法与前面讲过的Mixin扩展类提供的方法同名，所以我们可以通过继承Mixin扩展类来复用这些方法而无需自己编写。但是Mixin扩展类依赖与GenericAPIView，所以还需要继承GenericAPIView。

GenericViewSet就帮助我们完成了这样的继承工作，继承自GenericAPIView与ViewSetMixin，在实现了调用as_view()时传入字典（如&#123;&#x27;get&#x27;:&#x27;list&#x27;&#125;）的映射处理工作的同时，还提供了GenericAPIView提供的基础方法，可以直接搭配Mixin扩展类使用。</code></pre>

<p>举例</p>
<pre><code class="hljs plaintext">from rest_framework import mixins
from rest_framework.viewsets import GenericViewSet
from rest_framework.decorators import action

class BookInfoViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, GenericViewSet):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer</code></pre>

<p>url的定义</p>
<pre><code class="hljs plaintext">urlpatterns = [
    url(r&#x27;^books/$&#x27;, views.BookInfoViewSet.as_view(&#123;&#x27;get&#x27;: &#x27;list&#x27;&#125;)),
    url(r&#x27;^books/(?P&lt;pk&gt;\d+)/$&#x27;, views.BookInfoViewSet.as_view(&#123;&#x27;get&#x27;: &#x27;retrieve&#x27;&#125;)),
]</code></pre>

<p>(3) ModelViewSet</p>
<pre><code class="hljs plaintext">继承自GenericViewSet，同时包括了ListModelMixin、RetrieveModelMixin、CreateModelMixin、UpdateModelMixin、DestoryModelMixin。</code></pre>

<p>(4) ReadOnlyModelViewSet</p>
<p>继承自 <code>GenericViewSet</code>，同时包括了ListModelMixin、RetrieveModelMixin。</p>
<h4 id="3-4-2-视图集中定义附加action动作"><a href="#3-4-2-视图集中定义附加action动作" class="headerlink" title="3.4.2 视图集中定义附加action动作"></a>3.4.2 视图集中定义附加action动作</h4><p>在视图集中，除了上述默认的方法动作外，还可以添加自定义动作。</p>
<p>举例：</p>
<pre><code class="hljs plaintext">from rest_framework import mixins
from rest_framework.viewsets import GenericViewSet
from rest_framework.decorators import action

class BookInfoViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, GenericViewSet):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer

    def latest(self, request):
        &quot;&quot;&quot;
        返回最新的图书信息
        &quot;&quot;&quot;
        book = BookInfo.objects.latest(&#x27;id&#x27;)
        serializer = self.get_serializer(book)
        return Response(serializer.data)

    def read(self, request, pk):
        &quot;&quot;&quot;
        修改图书的阅读量数据
        &quot;&quot;&quot;
        book = self.get_object()
        book.bread = request.data.get(&#x27;read&#x27;)
        book.save()
        serializer = self.get_serializer(book)
        return Response(serializer.data)</code></pre>

<p>url的定义</p>
<pre><code class="hljs plaintext">urlpatterns = [
    url(r&#x27;^books/$&#x27;, views.BookInfoViewSet.as_view(&#123;&#x27;get&#x27;: &#x27;list&#x27;&#125;)),
    url(r&#x27;^books/latest/$&#x27;, views.BookInfoViewSet.as_view(&#123;&#x27;get&#x27;: &#x27;latest&#x27;&#125;)),
    url(r&#x27;^books/(?P&lt;pk&gt;\d+)/$&#x27;, views.BookInfoViewSet.as_view(&#123;&#x27;get&#x27;: &#x27;retrieve&#x27;&#125;)),
    url(r&#x27;^books/(?P&lt;pk&gt;\d+)/read/$&#x27;, views.BookInfoViewSet.as_view(&#123;&#x27;put&#x27;: &#x27;read&#x27;&#125;)),
]</code></pre>

<h4 id="3-4-3-action属性"><a href="#3-4-3-action属性" class="headerlink" title="3.4.3 action属性"></a>3.4.3 action属性</h4><pre><code class="hljs plaintext">from rest_framework.viewsets import ModelViewSet,ReadOnlyModelViewSet
from booktest.models import BookInfo
from .serializers import BookInfoModelSerializer
from rest_framework.response import Response
class BookInfoModelViewSet(ModelViewSet):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoModelSerializer

    def get_top_5(self,request):
        &quot;&quot;&quot;获取评论值最多的5条数据&quot;&quot;&quot;
        # 操作数据库
        print(self.action) # 获取本次请求的视图方法名</code></pre>

<p>通过路由访问到当前方法中，可以看到本次的action就是请求的方法名</p>
<h3 id="3-5-路由Routers"><a href="#3-5-路由Routers" class="headerlink" title="3.5 路由Routers"></a>3.5 路由Routers</h3><p>对于视图集ViewSet，我们除了可以自己手动指明请求方式与动作action之间的对应关系外，还可以使用Routers来帮助我们快速实现路由信息。</p>
<p>REST framework提供了两个router</p>
<ul>
<li><strong>SimpleRouter</strong></li>
<li><strong>DefaultRouter</strong></li>
</ul>
<h4 id="3-5-1-使用方法"><a href="#3-5-1-使用方法" class="headerlink" title="3.5.1 使用方法"></a>3.5.1 使用方法</h4><p>(1) 创建router对象，并注册视图集，例如</p>
<pre><code class="hljs plaintext">from rest_framework import routers

router = routers.SimpleRouter()
router.register(r&#x27;books&#x27;, BookInfoViewSet, base_name=&#x27;book&#x27;)</code></pre>

<p>register(prefix, viewset, base_name)</p>
<ul>
<li>prefix 该视图集的路由前缀</li>
<li>viewset 视图集</li>
<li>base_name 路由名称的前缀</li>
</ul>
<p>如上述代码会形成的路由如下：</p>
<pre><code class="hljs plaintext">^books/$    name: book-list
^books/&#123;pk&#125;/$   name: book-detail</code></pre>

<p>(2) 添加路由数据</p>
<p>可以有两种方式：</p>
<pre><code class="hljs plaintext">urlpatterns = [
    ...
]
urlpatterns += router.urls</code></pre>

<p>或</p>
<pre><code class="hljs plaintext">urlpatterns = [
    ...
    url(r&#x27;^&#x27;, include(router.urls))
]</code></pre>

<h4 id="3-5-2-视图集中附加action的声明"><a href="#3-5-2-视图集中附加action的声明" class="headerlink" title="3.5.2 视图集中附加action的声明"></a>3.5.2 视图集中附加action的声明</h4><p>在视图集中，如果想要让Router自动帮助我们为自定义的动作生成路由信息，需要使用 <code>rest_framework.decorators.action</code>装饰器。</p>
<p>以action装饰器装饰的方法名会作为action动作名，与list、retrieve等同。</p>
<p>action装饰器可以接收两个参数：</p>
<ul>
<li><p><strong>methods</strong> : 声明该action对应的请求方式，列表传递</p>
</li>
<li><p>detail声明该action的路径是否与单一资源对应，及是否是</p>
<pre><code class="hljs plaintext">xxx/&lt;pk&gt;/action方法名/</code></pre></li>
<li><p>True表示路径格式是：xxx&#x2F;<pk>&#x2F;action方法名&#x2F;</p>
</li>
<li><p>False表示路径格式是：xxx&#x2F;action方法名</p>
</li>
</ul>
<p>例如：</p>
<pre><code class="hljs plaintext">from rest_framework import mixins
from rest_framework.viewsets import GenericViewSet
from rest_framework.decorators import action

class BookInfoViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, GenericViewSet):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer

    # detail为False 表示路径名格式应该为 books/latest/
    @action(methods=[&#x27;get&#x27;], detail=False)
    def latest(self, request):
        &quot;&quot;&quot;
        返回最新的图书信息
        &quot;&quot;&quot;
        ...

    # detail为True，表示路径名格式应该为 books/&#123;pk&#125;/read/
    @action(methods=[&#x27;put&#x27;], detail=True)
    def read(self, request, pk):
        &quot;&quot;&quot;
        修改图书的阅读量数据
        &quot;&quot;&quot;
        ...</code></pre>

<p>由路由器自动为此视图集自定义action方法形成的路由会是如下内容：</p>
<pre><code class="hljs plaintext">^books/latest/$    name: book-latest
^books/&#123;pk&#125;/read/$  name: book-read</code></pre>

<h4 id="3-5-3-路由router形成URL的方法"><a href="#3-5-3-路由router形成URL的方法" class="headerlink" title="3.5.3 路由router形成URL的方法"></a>3.5.3 路由router形成URL的方法</h4><p>1） SimpleRouter</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16194/1671445017088/a16bf5dca5084794a9734c49c3c1de45.png" alt="image.png"></p>
<p>2）DefaultRouter</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16194/1671445017088/c4af57783b814f24b9f5c455111a05b1.png" alt="image.png"></p>
<p>DefaultRouter与SimpleRouter的区别是，DefaultRouter会多附带一个默认的API根视图，返回一个包含所有列表视图的超链接响应数据。</p>
<h2 id="4-JWT"><a href="#4-JWT" class="headerlink" title="4 JWT"></a>4 JWT</h2><p>JWT<br>JSON Web Token（JSON Web令牌）</p>
<p>是一个开放标准(rfc7519)，它定义了一种紧凑的、自包含的方式，用于在各方之间以JSON对象安全地传输信息。此信息可以验证和信任，因为它是数字签名的。jwt可以使用秘密〈使用HNAC算法）或使用RSA或ECDSA的公钥&#x2F;私钥对进行签名。</p>
<p>通过JSON形式作为Web应用中的令牌，用于在各方之间安全地将信息作为JSON对象传输。在数据传输过程中还可以完成数据加密、签名等相关处理。</p>
<p>JWT作用：<br>授权：一旦用户登录，每个后续请求将包括JWT，从而允许用户访问该令牌允许的路由，服务和资源。它的开销很小并且可以在不同的域中使用。如：单点登录。<br>信息交换：在各方之间安全地传输信息。JWT可进行签名（如使用公钥&#x2F;私钥对)，因此可确保发件人。由于签名是使用标头和有效负载计算的，因此还可验证内容是否被篡改。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20201029154848467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RvcF9MMzk4,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4Njwu2Yt-1603957559915)(E:%5CLiuPengLearn%5CLiuP%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B7%AF%5CJava%E6%8A%80%E6%9C%AF%E6%95%B4%E5%90%88%5CJWT%5Cimages%5Cimage-20200917201624900.png)]"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/482/1620998133146189824/98a020d466004863ac8da862b296cbae.png" alt="image.png"></p>
<pre><code class="hljs plaintext">1) jwt = base64(头部).base(载荷).hash256(base64(头部).base(载荷).密钥)
2) base64是可逆的算法、hash256是不可逆的算法
3) 密钥是固定的字符串，保存在服务器</code></pre>

<h3 id="4-1-DRF-JWT"><a href="#4-1-DRF-JWT" class="headerlink" title="4.1 DRF-JWT"></a>4.1 DRF-JWT</h3><p>官网：<a target="_blank" rel="noopener" href="http://getblimp.github.io/django-rest-framework-jwt/">http://getblimp.github.io/django-rest-framework-jwt/</a></p>
<h4 id="4-1-1-安装"><a href="#4-1-1-安装" class="headerlink" title="4.1.1 安装"></a>4.1.1 安装</h4><pre><code class="hljs plaintext">pip install djangorestframework-jwt</code></pre>

<h4 id="4-1-2-使用"><a href="#4-1-2-使用" class="headerlink" title="4.1.2 使用"></a>4.1.2 使用</h4><pre><code class="hljs plaintext">from django.urls import path
from rest_framework_jwt.views import obtain_jwt_token
urlpatterns = [
    path(&#x27;login/&#x27;, obtain_jwt_token),
]</code></pre>

<h4 id="4-1-3-测试"><a href="#4-1-3-测试" class="headerlink" title="4.1.3 测试"></a>4.1.3 测试</h4><p>(案例需要提前准备）</p>
<h4 id="4-1-4-DRF-JWT开发"><a href="#4-1-4-DRF-JWT开发" class="headerlink" title="4.1.4 DRF-JWT开发"></a>4.1.4 DRF-JWT开发</h4><p>配置信息：JWT_auth到dev.py中</p>
<pre><code class="hljs plaintext">import datetime
JWT_AUTH = &#123;
    # 过期时间
    &#x27;JWT_EXPIRATION_DELTA&#x27;: datetime.timedelta(days=1),
    # 自定义认证结果：见下方序列化user和自定义response
    &#x27;JWT_RESPONSE_PAYLOAD_HANDLER&#x27;: &#x27;user.utils.jwt_response_payload_handler&#x27;,  
&#125;</code></pre>

<p>序列化user：user&#x2F;serializers.py(自己创建)</p>
<pre><code class="hljs plaintext">from rest_framework import serializers
from . import models
class UserModelSerializers(serializers.ModelSerializer):
    class Meta:
        model = models.User
        fields = [&#x27;username&#x27;]</code></pre>

<p>自定义response：user&#x2F;utils.py</p>
<pre><code class="hljs plaintext">from .serializers import UserModelSerializers
def jwt_response_payload_handler(token, user=None, request=None):
    return &#123;
        &#x27;status&#x27;: 0,
        &#x27;msg&#x27;: &#x27;ok&#x27;,
        &#x27;data&#x27;: &#123;
            &#x27;token&#x27;: token,
            &#x27;user&#x27;: UserModelSerializers(user).data
        &#125;
    &#125;</code></pre>

<p>基于drf-jwt的全局认证：user&#x2F;authentications.py（自己创建）</p>
<pre><code class="hljs plaintext">import jwt
from rest_framework.exceptions import AuthenticationFailed
from rest_framework_jwt.authentication import jwt_decode_handler
from rest_framework_jwt.authentication import get_authorization_header
from rest_framework_jwt.authentication import BaseJSONWebTokenAuthentication

class JSONWebTokenAuthentication(BaseJSONWebTokenAuthentication):
    def authenticate(self, request):
        jwt_value = get_authorization_header(request)

        if not jwt_value:
            raise AuthenticationFailed(&#x27;Authorization 字段是必须的&#x27;)
        try:
            payload = jwt_decode_handler(jwt_value)
        except jwt.ExpiredSignature:
            raise AuthenticationFailed(&#x27;签名过期&#x27;)
        except jwt.InvalidTokenError:
            raise AuthenticationFailed(&#x27;非法用户&#x27;)
        user = self.authenticate_credentials(payload)

        return user, jwt_value</code></pre>

<p>全局启用：settings&#x2F;dev.py</p>
<pre><code class="hljs plaintext">REST_FRAMEWORK = &#123;
    # 认证模块
    &#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;: (
        &#x27;user.authentications.JSONWebTokenAuthentication&#x27;,
	# DRF自带的JWT认证模块
	#&#x27;rest_framework_jwt.authentication.JSONWebTokenAuthentication&#x27;,
    ),
&#125;
</code></pre>

<p>局部启用禁用：任何一个cvb类首行设置</p>
<pre><code class="hljs plaintext"># 局部禁用
authentication_classes = []

# 局部启用
from user.authentications import JSONWebTokenAuthentication
authentication_classes = [JSONWebTokenAuthentication]</code></pre>

<p>自定义代码登录：user&#x2F;utils.py</p>
<pre><code class="hljs plaintext">import re
from .models import User
from django.contrib.auth.backends import ModelBackend
class JWTModelBackend(ModelBackend):
    def authenticate(self, request, username=None, password=None, **kwargs):
        try:
            if re.match(r&#x27;^1[3-9]\d&#123;9&#125;$&#x27;, username):
                user = User.objects.get(mobile=username)
            else:
                user = User.objects.get(username=username)
        except User.DoesNotExist:
            return None
        if user.check_password(password) and self.user_can_authenticate(user):
            return user</code></pre>

<p>配置自定义登录：settings&#x2F;dev.py</p>
<pre><code class="hljs plaintext">AUTHENTICATION_BACKENDS = [&#x27;user.utils.JWTModelBackend&#x27;]</code></pre>

<p>手动签发JWT：</p>
<pre><code class="hljs plaintext">from rest_framework_jwt.settings import api_settings

jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER
jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER

payload = jwt_payload_handler(user)
token = jwt_encode_handler(payload)</code></pre>

<h2 id="5-Django-DRF序列化器-Serializer"><a href="#5-Django-DRF序列化器-Serializer" class="headerlink" title="5 Django DRF序列化器 Serializer"></a>5 Django DRF序列化器 Serializer</h2><h3 id="5-1-定义序列化器"><a href="#5-1-定义序列化器" class="headerlink" title="5.1 定义序列化器"></a>5.1 定义序列化器</h3><p>Django REST framework中的Serializer使用类来定义，须继承自rest_framework.serializers.Serializer。</p>
<p>例如，我们已有了一个数据库模型类BookInfo</p>
<pre><code class="hljs plaintext">class BookInfo(models.Model):
    btitle = models.CharField(max_length=20, verbose_name=&#x27;名称&#x27;)
    bpub_date = models.DateField(verbose_name=&#x27;发布日期&#x27;, null=True)
    bread = models.IntegerField(default=0, verbose_name=&#x27;阅读量&#x27;)
    bcomment = models.IntegerField(default=0, verbose_name=&#x27;评论量&#x27;)
    image = models.ImageField(upload_to=&#x27;booktest&#x27;, verbose_name=&#x27;图片&#x27;, null=True)</code></pre>

<p>我们想为这个模型类提供一个序列化器，可以定义如下：</p>
<pre><code class="hljs plaintext">class BookInfoSerializer(serializers.Serializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    id = serializers.IntegerField(label=&#x27;ID&#x27;, read_only=True)
    btitle = serializers.CharField(label=&#x27;名称&#x27;, max_length=20)
    bpub_date = serializers.DateField(label=&#x27;发布日期&#x27;, required=False)
    bread = serializers.IntegerField(label=&#x27;阅读量&#x27;, required=False)
    bcomment = serializers.IntegerField(label=&#x27;评论量&#x27;, required=False)
    image = serializers.ImageField(label=&#x27;图片&#x27;, required=False)</code></pre>

<p><strong>注意：serializer不是只能为数据库模型类定义，也可以为非数据库模型类的数据定义。</strong> serializer是独立于数据库之外的存在。</p>
<h4 id="常用字段类型"><a href="#常用字段类型" class="headerlink" title="常用字段类型"></a>常用字段类型</h4><p><strong>常用字段类型</strong> ：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字段构造方式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>BooleanField</strong></td>
<td>BooleanField()</td>
</tr>
<tr>
<td><strong>NullBooleanField</strong></td>
<td>NullBooleanField()</td>
</tr>
<tr>
<td><strong>CharField</strong></td>
<td>CharField(max_length&#x3D;None, min_length&#x3D;None, allow_blank&#x3D;False, trim_whitespace&#x3D;True)</td>
</tr>
<tr>
<td><strong>EmailField</strong></td>
<td>EmailField(max_length&#x3D;None, min_length&#x3D;None, allow_blank&#x3D;False)</td>
</tr>
<tr>
<td><strong>RegexField</strong></td>
<td>RegexField(regex, max_length&#x3D;None, min_length&#x3D;None, allow_blank&#x3D;False)</td>
</tr>
<tr>
<td><strong>SlugField</strong></td>
<td>SlugField(max_length&#x3D;50, min_length&#x3D;None, allow_blank&#x3D;False) 正则字段，验证正则模式 [a-zA-Z0-9*-]+</td>
</tr>
<tr>
<td><strong>URLField</strong></td>
<td>URLField(max_length&#x3D;200, min_length&#x3D;None, allow_blank&#x3D;False)</td>
</tr>
<tr>
<td><strong>UUIDField</strong></td>
<td>UUIDField(format&#x3D;’hex_verbose’) format: 1)<code>&#39;hex_verbose&#39;</code> 如 <code>&quot;5ce0e9a5-5ffa-654b-cee0-1238041fb31a&quot;</code> 2） <code>&#39;hex&#39;</code> 如 <code>&quot;5ce0e9a55ffa654bcee01238041fb31a&quot;</code> 3）<code>&#39;int&#39;</code> - 如: <code>&quot;123456789012312313134124512351145145114&quot;</code> 4）<code>&#39;urn&#39;</code> 如: <code>&quot;urn:uuid:5ce0e9a5-5ffa-654b-cee0-1238041fb31a&quot;</code></td>
</tr>
<tr>
<td><strong>IPAddressField</strong></td>
<td>IPAddressField(protocol&#x3D;’both’, unpack_ipv4&#x3D;False, **options)</td>
</tr>
<tr>
<td><strong>IntegerField</strong></td>
<td>IntegerField(max_value&#x3D;None, min_value&#x3D;None)</td>
</tr>
<tr>
<td><strong>FloatField</strong></td>
<td>FloatField(max_value&#x3D;None, min_value&#x3D;None)</td>
</tr>
<tr>
<td><strong>DecimalField</strong></td>
<td>DecimalField(max_digits, decimal_places, coerce_to_string&#x3D;None, max_value&#x3D;None, min_value&#x3D;None) max_digits: 最多位数 decimal_palces: 小数点位置</td>
</tr>
<tr>
<td><strong>DateTimeField</strong></td>
<td>DateTimeField(format&#x3D;api_settings.DATETIME_FORMAT, input_formats&#x3D;None)</td>
</tr>
<tr>
<td><strong>DateField</strong></td>
<td>DateField(format&#x3D;api_settings.DATE_FORMAT, input_formats&#x3D;None)</td>
</tr>
<tr>
<td><strong>TimeField</strong></td>
<td>TimeField(format&#x3D;api_settings.TIME_FORMAT, input_formats&#x3D;None)</td>
</tr>
<tr>
<td><strong>DurationField</strong></td>
<td>DurationField()</td>
</tr>
<tr>
<td><strong>ChoiceField</strong></td>
<td>ChoiceField(choices) choices与Django的用法相同</td>
</tr>
<tr>
<td><strong>MultipleChoiceField</strong></td>
<td>MultipleChoiceField(choices)</td>
</tr>
<tr>
<td><strong>FileField</strong></td>
<td>FileField(max_length&#x3D;None, allow_empty_file&#x3D;False, use_url&#x3D;UPLOADED_FILES_USE_URL)</td>
</tr>
<tr>
<td><strong>ImageField</strong></td>
<td>ImageField(max_length&#x3D;None, allow_empty_file&#x3D;False, use_url&#x3D;UPLOADED_FILES_USE_URL)</td>
</tr>
<tr>
<td><strong>ListField</strong></td>
<td>ListField(child&#x3D;, min_length&#x3D;None, max_length&#x3D;None)</td>
</tr>
<tr>
<td><strong>DictField</strong></td>
<td>DictField(child&#x3D;)</td>
</tr>
</tbody></table>
<h4 id="选项参数"><a href="#选项参数" class="headerlink" title="选项参数"></a>选项参数</h4><p><strong>选项参数：</strong></p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>max_length</strong></td>
<td>最大长度</td>
</tr>
<tr>
<td><strong>min_lenght</strong></td>
<td>最小长度</td>
</tr>
<tr>
<td><strong>allow_blank</strong></td>
<td>是否允许为空</td>
</tr>
<tr>
<td><strong>trim_whitespace</strong></td>
<td>是否截断空白字符</td>
</tr>
<tr>
<td><strong>max_value</strong></td>
<td>最小值</td>
</tr>
<tr>
<td><strong>min_value</strong></td>
<td>最大值</td>
</tr>
</tbody></table>
<h4 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h4><table>
<thead>
<tr>
<th>参数名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>read_only</strong></td>
<td>表明该字段仅用于序列化输出，默认False</td>
</tr>
<tr>
<td><strong>write_only</strong></td>
<td>表明该字段仅用于反序列化输入，默认False</td>
</tr>
<tr>
<td><strong>required</strong></td>
<td>表明该字段在反序列化时必须输入，默认True</td>
</tr>
<tr>
<td><strong>default</strong></td>
<td>反序列化时使用的默认值</td>
</tr>
<tr>
<td><strong>allow_null</strong></td>
<td>表明该字段是否允许传入None，默认False</td>
</tr>
<tr>
<td><strong>validators</strong></td>
<td>该字段使用的验证器</td>
</tr>
<tr>
<td><strong>error_messages</strong></td>
<td>包含错误编号与错误信息的字典</td>
</tr>
<tr>
<td><strong>label</strong></td>
<td>用于HTML展示API页面时，显示的字段名称</td>
</tr>
<tr>
<td><strong>help_text</strong></td>
<td>用于HTML展示API页面时，显示的字段帮助提示信息</td>
</tr>
</tbody></table>
<h3 id="5-2-创建Serializer对象"><a href="#5-2-创建Serializer对象" class="headerlink" title="5.2 创建Serializer对象"></a>5.2 创建Serializer对象</h3><p>序列化器有四大功能：</p>
<ul>
<li>反序列化 ： 把请求（request）中参数(字典) —–&gt; （模型）对象</li>
<li>请求参数校验 ：</li>
<li>保存和修改模型对象（数据库）：save</li>
<li>序列化： 把（模型）对象 ——&gt; 字典（—–&gt;json由response来完成）</li>
</ul>
<p>定义好Serializer类后，就可以创建Serializer对象了。</p>
<p>Serializer的构造方法为：</p>
<pre><code class="hljs plaintext">Serializer(instance=None, data=empty, **kwarg)</code></pre>

<p>说明：</p>
<p>1）用于序列化时，将模型类对象传入<strong>instance</strong>参数</p>
<p>2）用于反序列化时，将要被反序列化的数据传入<strong>data</strong>参数</p>
<p>3）除了instance和data参数外，在构造Serializer对象时，还可通过<strong>context</strong>参数额外添加数据，如</p>
<pre><code class="hljs plaintext">serializer = AccountSerializer(account, context=&#123;&#x27;request&#x27;: request&#125;)</code></pre>

<p><strong>通过context参数附加的数据，可以通过Serializer对象的context属性获取。</strong></p>
<ol>
<li>使用序列化器的时候一定要注意，序列化器声明了以后，不会自动执行，需要我们在视图中进行调用才可以。</li>
<li>序列化器无法直接接收数据，需要我们在视图中创建序列化器对象时把使用的数据传递过来。</li>
<li>序列化器的字段声明类似于我们前面使用过的表单系统。</li>
<li>开发restful api时，序列化器会帮我们把模型数据转换成字典.</li>
<li>drf提供的视图会帮我们把字典转换成json,或者把客户端发送过来的数据转换字典.</li>
</ol>
<p>序列化器的使用分两个阶段：</p>
<ol>
<li>在客户端请求时，使用序列化器可以完成对数据的反序列化。</li>
<li>在服务器响应时，使用序列化器可以完成对数据的序列化。</li>
</ol>
<h3 id="5-3-序列化"><a href="#5-3-序列化" class="headerlink" title="5.3 序列化"></a>5.3 序列化</h3><h4 id="5-3-1-基本使用"><a href="#5-3-1-基本使用" class="headerlink" title="5.3.1 基本使用"></a>5.3.1 基本使用</h4><p>(1) 先查询出一个图书对象</p>
<pre><code class="hljs plaintext">from booktest.models import BookInfo

book = BookInfo.objects.get(id=2)</code></pre>

<p>(2) 构造序列化对象</p>
<pre><code class="hljs plaintext">from booktest.serializers import BookInfoSerializer

serializer = BookInfoSerializer(book)</code></pre>

<p>(3) 获取序列化数据</p>
<p>通过data属性可以获取序列化后的数据</p>
<pre><code class="hljs plaintext">serializer.data
# &#123;&#x27;id&#x27;: 2, &#x27;btitle&#x27;: &#x27;天龙八部&#x27;, &#x27;bpub_date&#x27;: &#x27;1986-07-24&#x27;, &#x27;bread&#x27;: 36, &#x27;bcomment&#x27;: 40, &#x27;image&#x27;: None&#125;</code></pre>

<p>(4) 如果要被序列化的是包含多条数据的查询集QuerySet，可以通过添加many&#x3D;True参数补充说明</p>
<pre><code class="hljs plaintext">book_qs = BookInfo.objects.all()
serializer = BookInfoSerializer(book_qs, many=True)
serializer.data
# [OrderedDict([(&#x27;id&#x27;, 2), (&#x27;btitle&#x27;, &#x27;天龙八部&#x27;), (&#x27;bpub_date&#x27;, &#x27;1986-07-24&#x27;), (&#x27;bread&#x27;, 36), (&#x27;bcomment&#x27;, 40), (&#x27;image&#x27;, N]), OrderedDict([(&#x27;id&#x27;, 3), (&#x27;btitle&#x27;, &#x27;笑傲江湖&#x27;), (&#x27;bpub_date&#x27;, &#x27;1995-12-24&#x27;), (&#x27;bread&#x27;, 20), (&#x27;bcomment&#x27;, 80), (&#x27;image&#x27;ne)]), OrderedDict([(&#x27;id&#x27;, 4), (&#x27;btitle&#x27;, &#x27;雪山飞狐&#x27;), (&#x27;bpub_date&#x27;, &#x27;1987-11-11&#x27;), (&#x27;bread&#x27;, 58), (&#x27;bcomment&#x27;, 24), (&#x27;ima None)]), OrderedDict([(&#x27;id&#x27;, 5), (&#x27;btitle&#x27;, &#x27;西游记&#x27;), (&#x27;bpub_date&#x27;, &#x27;1988-01-01&#x27;), (&#x27;bread&#x27;, 10), (&#x27;bcomment&#x27;, 10), (&#x27;im&#x27;, &#x27;booktest/xiyouji.png&#x27;)])]</code></pre>

<h3 id="5-4-反序列化"><a href="#5-4-反序列化" class="headerlink" title="5.4 反序列化"></a>5.4 反序列化</h3><p>进行反序列化之前，必须先进行数据验证</p>
<p>使用序列化器进行反序列化时，需要对数据进行验证后，才能获取验证成功的数据或保存成模型类对象。</p>
<p>在获取反序列化的数据前，必须调用 <strong>is_valid()</strong> 方法进行验证，验证成功返回True，否则返回False。</p>
<p>验证失败，可以通过序列化器对象的<strong>errors</strong>属性获取错误信息，返回字典，包含了字段和字段的错误。如果是非字段错误，可以通过修改REST framework配置中的<strong>NON_FIELD_ERRORS_KEY</strong>来控制错误字典中的键名。</p>
<p>验证成功，可以通过序列化器对象的<strong>validated_data</strong>属性获取数据。</p>
<p>在定义序列化器时，指明每个字段的序列化类型和选项参数，本身就是一种验证行为。</p>
<p>如我们前面定义过的BookInfoSerializer</p>
<pre><code class="hljs plaintext">class BookInfoSerializer(serializers.Serializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    id = serializers.IntegerField(label=&#x27;ID&#x27;, read_only=True)
    btitle = serializers.CharField(label=&#x27;名称&#x27;, max_length=20)
    bpub_date = serializers.DateField(label=&#x27;发布日期&#x27;, required=False)
    bread = serializers.IntegerField(label=&#x27;阅读量&#x27;, required=False)
    bcomment = serializers.IntegerField(label=&#x27;评论量&#x27;, required=False)
    image = serializers.ImageField(label=&#x27;图片&#x27;, required=False)</code></pre>

<p>通过构造序列化器对象，并将要反序列化的数据传递给data构造参数，进而进行验证</p>
<pre><code class="hljs plaintext">from booktest.serializers import BookInfoSerializer
data = &#123;&#x27;bpub_date&#x27;: 123&#125;
serializer = BookInfoSerializer(data=data)
serializer.is_valid()  # 返回False
serializer.errors
# &#123;&#x27;btitle&#x27;: [ErrorDetail(string=&#x27;This field is required.&#x27;, code=&#x27;required&#x27;)], &#x27;bpub_date&#x27;: [ErrorDetail(string=&#x27;Date has wrong format. Use one of these formats instead: YYYY[-MM[-DD]].&#x27;, code=&#x27;invalid&#x27;)]&#125;
serializer.validated_data  # &#123;&#125;

data = &#123;&#x27;btitle&#x27;: &#x27;python&#x27;&#125;
serializer = BookInfoSerializer(data=data)
serializer.is_valid()  # True
serializer.errors  # &#123;&#125;
serializer.validated_data  #  OrderedDict([(&#x27;btitle&#x27;, &#x27;python&#x27;)])</code></pre>

<p>is_valid()方法还可以在验证失败时抛出异常serializers.ValidationError，可以通过传递<strong>raise_exception&#x3D;True</strong>参数开启，REST framework接收到此异常，会向前端返回HTTP 400 Bad Request响应。</p>
<pre><code class="hljs plaintext"># Return a 400 response if the data was invalid.
serializer.is_valid(raise_exception=True)</code></pre>

<p>(1) validate_字段名</p>
<p>对<field_name>字典进行验证，如：</p>
<pre><code class="hljs plaintext">class BookInfoSerializer(serializers.Serializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    ...

    def validate_btitle(self, value):
        if &#x27;django&#x27; not in value.lower():
            raise serializers.ValidationError(&quot;图书不是关于Django的&quot;)
        return value</code></pre>

<p>测试：</p>
<pre><code class="hljs plaintext">from booktest.serializers import BookInfoSerializer
data = &#123;&#x27;btitle&#x27;: &#x27;python&#x27;&#125;
serializer = BookInfoSerializer(data=data)
serializer.is_valid()  # False   
serializer.errors
#  &#123;&#x27;btitle&#x27;: [ErrorDetail(string=&#x27;图书不是关于Django的&#x27;, code=&#x27;invalid&#x27;)]&#125;</code></pre>

<p>(2) validate</p>
<p>在序列化器中需要同时对多个字段进行比较验证时，可以定义validate方法来验证，如</p>
<pre><code class="hljs plaintext">from booktest.serializers import BookInfoSerializer
data = &#123;&#x27;btitle&#x27;: &#x27;about django&#x27;, &#x27;bread&#x27;: 10, &#x27;bcomment&#x27;: 20&#125;
s = BookInfoSerializer(data=data)
s.is_valid()  # False
s.errors
#  &#123;&#x27;non_field_errors&#x27;: [ErrorDetail(string=&#x27;阅读量小于评论量&#x27;, code=&#x27;invalid&#x27;)]&#125;</code></pre>

<p>(3) validators</p>
<p>在字段中添加validators选项参数，也可以补充验证行为，如</p>
<pre><code class="hljs plaintext">def about_django(value):
    if &#x27;django&#x27; not in value.lower():
        raise serializers.ValidationError(&quot;图书不是关于Django的&quot;)

class BookInfoSerializer(serializers.Serializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    id = serializers.IntegerField(label=&#x27;ID&#x27;, read_only=True)
    btitle = serializers.CharField(label=&#x27;名称&#x27;, max_length=20, validators=[about_django])
    bpub_date = serializers.DateField(label=&#x27;发布日期&#x27;, required=False)
    bread = serializers.IntegerField(label=&#x27;阅读量&#x27;, required=False)
    bcomment = serializers.IntegerField(label=&#x27;评论量&#x27;, required=False)
    image = serializers.ImageField(label=&#x27;图片&#x27;, required=False)</code></pre>

<p>测试：</p>
<pre><code class="hljs plaintext">from booktest.serializers import BookInfoSerializer
data = &#123;&#x27;btitle&#x27;: &#x27;python&#x27;&#125;
serializer = BookInfoSerializer(data=data)
serializer.is_valid()  # False   
serializer.errors
#  &#123;&#x27;btitle&#x27;: [ErrorDetail(string=&#x27;图书不是关于Django的&#x27;, code=&#x27;invalid&#x27;)]&#125;</code></pre>

<h3 id="反序列化-保存数据"><a href="#反序列化-保存数据" class="headerlink" title="反序列化-保存数据"></a>反序列化-保存数据</h3><p>前面的验证数据成功后,我们可以使用序列化器来完成数据反序列化的过程.这个过程可以把数据转成模型类对象.</p>
<p>可以通过实现create()和update()两个方法来实现。</p>
<pre><code class="hljs plaintext">class BookInfoSerializer(serializers.Serializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    ...

    def create(self, validated_data):
        &quot;&quot;&quot;新建&quot;&quot;&quot;
        return BookInfo(**validated_data)

    def update(self, instance, validated_data):
        &quot;&quot;&quot;更新，instance为要更新的对象实例&quot;&quot;&quot;
        instance.btitle = validated_data.get(&#x27;btitle&#x27;, instance.btitle)
        instance.bpub_date = validated_data.get(&#x27;bpub_date&#x27;, instance.bpub_date)
        instance.bread = validated_data.get(&#x27;bread&#x27;, instance.bread)
        instance.bcomment = validated_data.get(&#x27;bcomment&#x27;, instance.bcomment)
        return instance</code></pre>

<p>如果需要在返回数据对象的时候，也将数据保存到数据库中，则可以进行如下修改</p>
<pre><code class="hljs plaintext">
class BookInfoSerializer(serializers.Serializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    ...

    def create(self, validated_data):
        &quot;&quot;&quot;新建&quot;&quot;&quot;
        return BookInfo.objects.create(**validated_data)

    def update(self, instance, validated_data):
        &quot;&quot;&quot;更新，instance为要更新的对象实例&quot;&quot;&quot;
        instance.btitle = validated_data.get(&#x27;btitle&#x27;, instance.btitle)
        instance.bpub_date = validated_data.get(&#x27;bpub_date&#x27;, instance.bpub_date)
        instance.bread = validated_data.get(&#x27;bread&#x27;, instance.bread)
        instance.bcomment = validated_data.get(&#x27;bcomment&#x27;, instance.bcomment)
        instance.save()
        return instance</code></pre>

<p>实现了上述两个方法后，在反序列化数据的时候，就可以通过save()方法返回一个数据对象实例了</p>
<pre><code class="hljs plaintext">book = serializer.save()</code></pre>

<p>如果创建序列化器对象的时候，没有传递instance实例，则调用save()方法的时候，create()被调用，相反，如果传递了instance实例，则调用save()方法的时候，update()被调用。</p>
<pre><code class="hljs plaintext">from db.serializers import BookInfoSerializer
data = &#123;&#x27;btitle&#x27;: &#x27;封神演义&#x27;&#125;
serializer = BookInfoSerializer(data=data)
serializer.is_valid()  # True
serializer.save()  # &lt;BookInfo: 封神演义&gt;

from db.models import BookInfo
book = BookInfo.objects.get(id=2)
data = &#123;&#x27;btitle&#x27;: &#x27;倚天剑&#x27;&#125;
serializer = BookInfoSerializer(book, data=data)
serializer.is_valid()  # True
serializer.save()  # &lt;BookInfo: 倚天剑&gt;
book.btitle  # &#x27;倚天剑&#x27;</code></pre>

<p>说明：</p>
<p>（1）在对序列化器进行save()保存时，可以额外传递数据，这些数据可以在create()和update()中的validated_data参数获取到</p>
<pre><code class="hljs plaintext"># request.user 是django中记录当前登录用户的模型对象
serializer.save(owner=request.user)</code></pre>

<p>（2）默认序列化器必须传递所有required的字段，否则会抛出验证异常。但是我们可以使用partial参数来允许部分字段更新</p>
<pre><code class="hljs plaintext"># Update `comment` with partial data
serializer = CommentSerializer(comment, data=&#123;&#x27;content&#x27;: u&#x27;foo bar&#x27;&#125;, partial=True)</code></pre>

<h3 id="模型类序列化器"><a href="#模型类序列化器" class="headerlink" title="模型类序列化器"></a>模型类序列化器</h3><p>如果我们想要使用序列化器对应的是Django的模型类，DRF为我们提供了ModelSerializer模型类序列化器来帮助我们快速创建一个Serializer类。</p>
<p>ModelSerializer与常规的Serializer相同，但提供了：</p>
<ul>
<li>基于模型类自动生成一系列字段</li>
<li>基于模型类自动为Serializer生成validators，比如unique_together</li>
<li>包含默认的create()和update()的实现</li>
</ul>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>比如我们创建一个BookInfoSerializer</p>
<pre><code class="hljs plaintext">class BookInfoSerializer(serializers.ModelSerializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    class Meta:
        model = BookInfo
        fields = &#x27;__all__&#x27;</code></pre>

<ul>
<li>model 指明参照哪个模型类</li>
<li>fields 指明为模型类的哪些字段生成</li>
</ul>
<p>我们可以在python manage.py shell中查看自动生成的BookInfoSerializer的具体实现</p>
<pre><code class="hljs plaintext">&gt;&gt;&gt; from booktest.serializers import BookInfoSerializer
&gt;&gt;&gt; serializer = BookInfoSerializer()
&gt;&gt;&gt; serializer
BookInfoSerializer():
    id = IntegerField(label=&#x27;ID&#x27;, read_only=True)
    btitle = CharField(label=&#x27;名称&#x27;, max_length=20)
    bpub_date = DateField(allow_null=True, label=&#x27;发布日期&#x27;, required=False)
    bread = IntegerField(label=&#x27;阅读量&#x27;, max_value=2147483647, min_value=-2147483648, required=False)
    bcomment = IntegerField(label=&#x27;评论量&#x27;, max_value=2147483647, min_value=-2147483648, required=False)
    image = ImageField(allow_null=True, label=&#x27;图片&#x27;, max_length=100, required=False)</code></pre>

<h4 id="指定字段"><a href="#指定字段" class="headerlink" title="指定字段"></a>指定字段</h4><p>使用<strong>fields</strong>来明确字段，<code>__all__</code>表名包含所有字段，也可以写明具体哪些字段，如</p>
<pre><code class="hljs plaintext">class BookInfoSerializer(serializers.ModelSerializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    class Meta:
        model = BookInfo
        fields = (&#x27;id&#x27;, &#x27;btitle&#x27;, &#x27;bpub_date&#x27;)</code></pre>

<p>使用exclude可以明确排序掉哪些字段</p>
<pre><code class="hljs plaintext">class BookInfoSerializer(serializers.ModelSerializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    class Meta:
        model = BookInfo
        exclude = (&#x27;image&#x27;,)</code></pre>

<p>显示指明字段，如：</p>
<pre><code class="hljs plaintext">class HeroInfoSerializer(serializers.ModelSerializer):
    hbook = BookInfoSerializer()

    class Meta:
        model = HeroInfo
        fields = (&#x27;id&#x27;, &#x27;hname&#x27;, &#x27;hgender&#x27;, &#x27;hcomment&#x27;, &#x27;hbook&#x27;)</code></pre>

<p>指明只读字段</p>
<p>可以通过read_only_fields指明只读字段，既仅用于序列化输出的字段</p>
<pre><code class="hljs plaintext">class BookInfoSerializer(serializers.ModelSerializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    class Meta:
        model = BookInfo
        fields = (&#x27;id&#x27;, &#x27;btitle&#x27;, &#x27;bpub_date&#x27;， &#x27;bread&#x27;, &#x27;bcomment&#x27;)
        read_only_fields = (&#x27;id&#x27;, &#x27;bread&#x27;, &#x27;bcomment&#x27;)</code></pre>

<h4 id="添加额外参数"><a href="#添加额外参数" class="headerlink" title="添加额外参数"></a>添加额外参数</h4><p>我们可以使用extra_kwargs参数为ModelSerializer添加或修改原有的选项参数</p>
<pre><code class="hljs plaintext">class BookInfoSerializer(serializers.ModelSerializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    class Meta:
        model = BookInfo
        fields = (&#x27;id&#x27;, &#x27;btitle&#x27;, &#x27;bpub_date&#x27;, &#x27;bread&#x27;, &#x27;bcomment&#x27;)
        extra_kwargs = &#123;
            &#x27;bread&#x27;: &#123;&#x27;min_value&#x27;: 0, &#x27;required&#x27;: True&#125;,
            &#x27;bcomment&#x27;: &#123;&#x27;min_value&#x27;: 0, &#x27;required&#x27;: True&#125;,
        &#125;

# BookInfoSerializer():
#    id = IntegerField(label=&#x27;ID&#x27;, read_only=True)
#    btitle = CharField(label=&#x27;名称&#x27;, max_length=20)
#    bpub_date = DateField(allow_null=True, label=&#x27;发布日期&#x27;, required=False)
#    bread = IntegerField(label=&#x27;阅读量&#x27;, max_value=2147483647, min_value=0, required=True)
#    bcomment = IntegerField(label=&#x27;评论量&#x27;, max_value=2147483647, min_value=0, required=True)</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">yncaqy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/14/DRF/">http://example.com/2023/04/14/DRF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">YNCAQY</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/test/">test</a></div><div class="post_share"><div class="social-share" data-image="/img%5C2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/04/14/ync-1/" title="ync"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ync</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/04/14/hello-world/" title="Hello World"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img%5C4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-14</div><div class="title">Hello World</div></div></a></div><div><a href="/2023/04/14/ync-1/" title="ync"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-14</div><div class="title">ync</div></div></a></div><div><a href="/2023/04/14/AQY/" title="AQY"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img%5C3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-14</div><div class="title">AQY</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#DRF%E6%A1%86%E6%9E%B6"><span class="toc-number">1.</span> <span class="toc-text">DRF框架</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-DRF%E5%85%A5%E9%97%A8"><span class="toc-number"></span> <span class="toc-text">1 DRF入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-RESTful"><span class="toc-number"></span> <span class="toc-text">1.1 RESTful</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-API%E6%8E%A5%E5%8F%A3%E5%92%8C-RESTful-API%E8%A7%84%E8%8C%83"><span class="toc-number"></span> <span class="toc-text">1.2 API接口和 RESTful API规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Django-RESTful%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85"><span class="toc-number"></span> <span class="toc-text">1.3 Django-RESTful介绍与安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">1.3.1 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E5%AE%89%E8%A3%85DRF"><span class="toc-number">2.</span> <span class="toc-text">1.3.2 安装DRF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-%E9%85%8D%E7%BD%AEDRF"><span class="toc-number">3.</span> <span class="toc-text">1.3.3 配置DRF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-serializer-py%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BA%8F%E5%88%97%E5%8C%96%E7%B1%BB%EF%BC%88%E8%AF%A5%E6%96%87%E4%BB%B6%E4%B9%9F%E8%87%AA%E5%B7%B1%E5%88%9B%E5%BB%BA%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">1.3.4 serializer.py新建一个序列化类（该文件也自己创建）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-5-%E8%A7%86%E5%9B%BE%E7%B1%BB"><span class="toc-number">5.</span> <span class="toc-text">1.3.5 视图类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-6-%E7%BC%96%E5%86%99%E8%B7%AF%E7%94%B1"><span class="toc-number">6.</span> <span class="toc-text">1.3.6 编写路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-7-%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%A7%8B%E6%B5%8B%E8%AF%95"><span class="toc-number">7.</span> <span class="toc-text">1.3.7 启动项目开始测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-DRF%E5%8A%9F%E8%83%BD%E7%BB%84%E4%BB%B6"><span class="toc-number"></span> <span class="toc-text">2 DRF功能组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%AE%A4%E8%AF%81Authentication"><span class="toc-number"></span> <span class="toc-text">2.1 认证Authentication</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E8%AE%A4%E8%AF%81%E9%85%8D%E7%BD%AE"><span class="toc-number">1.</span> <span class="toc-text">2.1.1 认证配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E8%AE%A4%E8%AF%81%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">2.1.2 认证使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-number">3.</span> <span class="toc-text">2.1.3 提供的权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9D%83%E9%99%90"><span class="toc-number">4.</span> <span class="toc-text">2.1.4 自定义权限</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%99%90%E6%B5%81Throttling"><span class="toc-number"></span> <span class="toc-text">2.2 限流Throttling</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E9%99%90%E6%B5%81%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">2.2.1 限流介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E9%99%90%E6%B5%81%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">2.2.2 限流使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E5%8F%AF%E9%80%89%E9%99%90%E6%B5%81%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">2.2.3 可选限流类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-%E6%A1%88%E4%BE%8B"><span class="toc-number">4.</span> <span class="toc-text">2.2.4 案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%BF%87%E6%BB%A4Filtering"><span class="toc-number"></span> <span class="toc-text">2.3 过滤Filtering</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">2.3.1 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E6%8E%92%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">2.3.2 排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%88%86%E9%A1%B5"><span class="toc-number"></span> <span class="toc-text">2.4 分页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">2.4.1 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E5%8F%AF%E9%80%89%E5%88%86%E9%A1%B5%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">2.4.2 可选分页器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86Exceptions"><span class="toc-number"></span> <span class="toc-text">2.5 异常处理Exceptions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3"><span class="toc-number"></span> <span class="toc-text">2.6 自动生成接口文档</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96"><span class="toc-number">1.</span> <span class="toc-text">2.6.1 安装依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-%E8%AE%BE%E7%BD%AE%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">2.</span> <span class="toc-text">2.6.2 设置接口文档访问路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3-%E6%96%87%E6%A1%A3%E6%8F%8F%E8%BF%B0%E8%AF%B4%E6%98%8E%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BD%8D%E7%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">2.6.3 文档描述说明的定义位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-4-%E8%AE%BF%E9%97%AE%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E7%BD%91%E9%A1%B5"><span class="toc-number">4.</span> <span class="toc-text">2.6.4 访问接口文档网页</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-DRF%E8%A7%86%E5%9B%BE%E5%AE%B6%E6%97%8F"><span class="toc-number"></span> <span class="toc-text">3 DRF视图家族</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%B8%A4%E4%B8%AA%E8%A7%86%E5%9B%BE%E5%9F%BA%E7%B1%BB"><span class="toc-number"></span> <span class="toc-text">3.1 两个视图基类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-APIView"><span class="toc-number">1.</span> <span class="toc-text">3.1.1 APIView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-GenericAPIView"><span class="toc-number">2.</span> <span class="toc-text">3.1.2 GenericAPIView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-DRF%E7%9A%84%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">3.1.3 DRF的请求对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89-data"><span class="toc-number">3.1.</span> <span class="toc-text">1）.data</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89-query-params"><span class="toc-number">3.2.</span> <span class="toc-text">2）.query_params</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89request-request"><span class="toc-number">3.3.</span> <span class="toc-text">3）request._request</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-DRF%E7%9A%84%E5%93%8D%E5%BA%94%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.</span> <span class="toc-text">3.1.4 DRF的响应对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89response%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">1）response的构造方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89response%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">4.2.</span> <span class="toc-text">2）response对象的状态码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-5-%E8%A7%86%E5%9B%BE%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">3.1.5 视图类源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81View%E7%B1%BB%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">5.1.</span> <span class="toc-text">1、View类的源码解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81APIView%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">5.2.</span> <span class="toc-text">2、APIView源码解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81GenericAPIView%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">5.3.</span> <span class="toc-text">3、GenericAPIView源码解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-5%E4%B8%AA%E8%A7%86%E5%9B%BE%E6%89%A9%E5%B1%95%E7%B1%BB"><span class="toc-number"></span> <span class="toc-text">3.2  5个视图扩展类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ListModeMixin"><span class="toc-number">1.</span> <span class="toc-text">(1) ListModeMixin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-CreateModeMixin"><span class="toc-number">2.</span> <span class="toc-text">(2) CreateModeMixin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-RetrieveModelMixin"><span class="toc-number">3.</span> <span class="toc-text">(3) RetrieveModelMixin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-UpdateModelMixin"><span class="toc-number">4.</span> <span class="toc-text">(4) UpdateModelMixin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-DestroyModelMixin"><span class="toc-number">5.</span> <span class="toc-text">(5) DestroyModelMixin</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%87%A0%E4%B8%AA%E5%AD%90%E7%B1%BB%E8%A7%86%E5%9B%BE"><span class="toc-number"></span> <span class="toc-text">3.3 几个子类视图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89CreateAPIView"><span class="toc-number">1.</span> <span class="toc-text">(1）CreateAPIView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89ListAPIView"><span class="toc-number">2.</span> <span class="toc-text">(2）ListAPIView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89RetrieveAPIView"><span class="toc-number">3.</span> <span class="toc-text">(3）RetrieveAPIView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89DestoryAPIView"><span class="toc-number">4.</span> <span class="toc-text">(4）DestoryAPIView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%89UpdateAPIView"><span class="toc-number">5.</span> <span class="toc-text">(5）UpdateAPIView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%EF%BC%89RetrieveUpdateAPIView"><span class="toc-number">6.</span> <span class="toc-text">6）RetrieveUpdateAPIView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%EF%BC%89RetrieveUpdateDestoryAPIView"><span class="toc-number">7.</span> <span class="toc-text">7）RetrieveUpdateDestoryAPIView</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E8%A7%86%E5%9B%BE%E9%9B%86ViewSet"><span class="toc-number"></span> <span class="toc-text">3.4 视图集ViewSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E5%B8%B8%E7%94%A8%E8%A7%86%E5%9B%BE%E9%9B%86%E7%88%B6%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">3.4.1 常用视图集父类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E8%A7%86%E5%9B%BE%E9%9B%86%E4%B8%AD%E5%AE%9A%E4%B9%89%E9%99%84%E5%8A%A0action%E5%8A%A8%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">3.4.2 视图集中定义附加action动作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-action%E5%B1%9E%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">3.4.3 action属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E8%B7%AF%E7%94%B1Routers"><span class="toc-number"></span> <span class="toc-text">3.5 路由Routers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">3.5.1 使用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-%E8%A7%86%E5%9B%BE%E9%9B%86%E4%B8%AD%E9%99%84%E5%8A%A0action%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">2.</span> <span class="toc-text">3.5.2 视图集中附加action的声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-3-%E8%B7%AF%E7%94%B1router%E5%BD%A2%E6%88%90URL%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">3.5.3 路由router形成URL的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-JWT"><span class="toc-number"></span> <span class="toc-text">4 JWT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-DRF-JWT"><span class="toc-number"></span> <span class="toc-text">4.1 DRF-JWT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E5%AE%89%E8%A3%85"><span class="toc-number">1.</span> <span class="toc-text">4.1.1 安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">4.1.2 使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-%E6%B5%8B%E8%AF%95"><span class="toc-number">3.</span> <span class="toc-text">4.1.3 测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-DRF-JWT%E5%BC%80%E5%8F%91"><span class="toc-number">4.</span> <span class="toc-text">4.1.4 DRF-JWT开发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Django-DRF%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8-Serializer"><span class="toc-number"></span> <span class="toc-text">5 Django DRF序列化器 Serializer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8"><span class="toc-number"></span> <span class="toc-text">5.1 定义序列化器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">常用字段类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E9%A1%B9%E5%8F%82%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">选项参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">通用参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%88%9B%E5%BB%BASerializer%E5%AF%B9%E8%B1%A1"><span class="toc-number"></span> <span class="toc-text">5.2 创建Serializer对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number"></span> <span class="toc-text">5.3 序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">5.3.1 基本使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number"></span> <span class="toc-text">5.4 反序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE"><span class="toc-number"></span> <span class="toc-text">反序列化-保存数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E7%B1%BB%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8"><span class="toc-number"></span> <span class="toc-text">模型类序列化器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5"><span class="toc-number">2.</span> <span class="toc-text">指定字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E9%A2%9D%E5%A4%96%E5%8F%82%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">添加额外参数</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By yncaqy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi,Welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>